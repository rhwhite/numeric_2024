<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Lab 2: Stability and accuracy &#8212; Numeric course 22.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../../_static/mozilla.css?v=18700206" />
    <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css?v=2aa19091" />
    <script src="../../_static/documentation_options.js?v=f6d600a2"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="../../_static/UBC_EOAS_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Laboratory 3: Linear Algebra (Sept. 12, 2017)" href="../lab3/01-lab3.html" />
    <link rel="prev" title="Laboratory 1: An Introduction to the Numerical Solution of Differential Equations: Discretization (Jan 2024)" href="../lab1/01-lab1.html" /> 
  </head><body>
<!-- remove Mozilla link tab from upper right corner of page -->


    <div class="document">
  <div class="documentwrapper">
    
    <div class="sphinxsidebar">
        <nav>
        <h2><a href="../../index.html">Numeric course</a></h2>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../ugradsyllabus.html">Undergrad Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ugrad_schedule.html">Undergrad Detailed Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gradsyllabus.html">Grad Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../grad_schedule.html">Grad Detailed Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../texts.html">Optional texts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../notebook_toc.html">Labs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rubrics.html">Rubrics</a></li>
</ul>

        </nav>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
    </div>
    <div class="bodywrapper">
      <div class="body">
        
  <section id="Lab-2:-Stability-and-accuracy">
<h1>Lab 2: Stability and accuracy<a class="headerlink" href="#Lab-2:-Stability-and-accuracy" title="Link to this heading">¶</a></h1>
<p><strong>Important - before you start</strong></p>
<p>Before starting on a new lab, you should “fetch” any changes that we have made to the labs in our repository (we are continually trying to improve them). Follow the instructions here: <a class="reference external" href="https://rhwhite.github.io/numeric_2024/getting_started/python.html#Pulling-changes-from-the-github-repository">https://rhwhite.github.io/numeric_2024/getting_started/python.html#Pulling-changes-from-the-github-repository</a></p>
<p>Caution - if you have made changes to, for example, lab 1, but you didn’t duplicate and rename the file first, this can write over your changes! Follow the instructions above carefully to not lose your work, and remember to always create a copy of each lab for you to do your work in.</p>
<p>This step will be smoother if you haven’t saved any changes to the default files (sometimes even opening it, and saving it, counts as a change!)</p>
<p><strong>Some notes about navigating in Jupyter Lab</strong></p>
<p>In Jupyter Lab, once you have opened a lab, if you click on the symbol that looks like three bullet points over on the far left, this brings up a contents page that allows you to jump immediately to any particular section in the lab you are currently looking at.</p>
<p>The jigsaw puzzle icon below this allows you to install extensions, if you want extra functionality in your notebooks (you may need to go to Settings, Enable Extension Manager to access this).</p>
<p>Also, in Jupyter Lab you can click on links in the ‘List of Problems’ to take you to directly to each problem. Remember to check canvas for which problems you need to submit for the weekly assignments.</p>
<section id="List-of-Problems">
<h2>List of Problems<a class="headerlink" href="#List-of-Problems" title="Link to this heading">¶</a></h2>
<p>There are probems throughout this lab, as you might find at the end of a textbook chapter. Some of these problems will be set as an assignment for you to hand in to be graded - see the Lab 2: Assignment on the canvas site for which problems you should hand in. However, if you have time, you are encouraged to work through all of these problems to help you better understand the material.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#Problem-Accuracy"><span class="std std-ref">Problem Accuracy</span></a></p></li>
<li><p><a class="reference internal" href="#Problem-Stability"><span class="std std-ref">Problem Stability</span></a></p></li>
<li><p><a class="reference internal" href="#Problem-Backward-Euler"><span class="std std-ref">Problem Backward-Euler</span></a></p></li>
<li><p><a class="reference internal" href="#Problem-Taylor-Series"><span class="std std-ref">Problem Taylor Series</span></a></p></li>
</ul>
</section>
<section id="Objectives">
<h2>Objectives<a class="headerlink" href="#Objectives" title="Link to this heading">¶</a></h2>
<p>In Lab #1 you were introduced to the concept of discretization, and saw that there were many different ways to approximate a given problem. This Lab will delve further into the concepts of accuracy and stability of numerical schemes, in order that we can compare the many possible discretizations.</p>
<p>At the end of this Lab, you will have seen where the error in a numerical scheme comes from, and how to quantify the error in terms of <em>order</em>. The stability of several examples will be demonstrated, so that you can recognize when a scheme is unstable, and how one might go about modifying the scheme to eliminate the instability.</p>
<p>Specifically you will be able to:</p>
<ul class="simple">
<li><p>Define the term and identify: Implicit numerical scheme and Explicit numerical scheme.</p></li>
<li><p>Define the term, identify, or write down for a given equation: Backward Euler method and Forward Euler method.</p></li>
<li><p>Explain the difference in terminology between: Forward difference discretization and Forward Euler method.</p></li>
<li><p>Define: truncation error, local truncation error, global truncation error, and stiff equation.</p></li>
<li><p>Explain: a predictor-corrector method.</p></li>
<li><p>Identify from a plot: an unstable numerical solution.</p></li>
<li><p>Be able to: find the order of a scheme, use the test equation to find the stability of a scheme, find the local truncation error from a graph of the exact solution and the numerical solution.</p></li>
<li><p>Evaluate and compare the accuracy and stability of at least 3 different discretization methods.</p></li>
</ul>
</section>
<section id="Readings">
<h2>Readings<a class="headerlink" href="#Readings" title="Link to this heading">¶</a></h2>
<p>This lab is designed to be self-contained. If you would like additional background on any of the following topics, I’d recommend this book: <a class="reference external" href="https://link-springer-com.ezproxy.library.ubc.ca/book/10.1007/978-3-319-55456-3">Finite difference computing with PDES</a> by Hans Petter Langtangen and Svein Linge The entire book is available on <a class="reference external" href="http://hplgit.github.io/fdm-book/doc/pub/book/html/decay-book.html">github</a> with the python code
<a class="reference external" href="https://github.com/hplgit/fdm-book/tree/master/src">here</a>. Much of the content of this lab is summarized in <a class="reference external" href="https://link-springer-com.ezproxy.library.ubc.ca/content/pdf/bbm%3A978-3-319-55456-3%2F1.pdf">Appendix B – truncation analysis</a></p>
<section id="Other-recommended-books">
<h3>Other recommended books<a class="headerlink" href="#Other-recommended-books" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Differential Equations:</strong></p>
<ul>
<li><p>Strang (1986), Chapter 6 (ODE’s).</p></li>
</ul>
</li>
<li><p><strong>Numerical Methods:</strong></p>
<ul>
<li><p>Strang (1986), Section 6.5 (a great overview of difference methods for initial value problems)</p></li>
<li><p>Burden and Faires (1981), Chapter 5 (a more in-depth analysis of the numerical methods and their accuracy and stability).</p></li>
<li><p>Newman (2013) Derivatives, round-off and truncation errors, Section 5.10 pp. 188-198. Forward Euler, mid-point and leap-frog methods, Chapter 8 pp. 327-335.</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="Introduction">
<h2>Introduction<a class="headerlink" href="#Introduction" title="Link to this heading">¶</a></h2>
<p>Remember from Lab #1  that you were introduced to three approximations to the first derivative of a function, <span class="math notranslate nohighlight">\(T^\prime(t)\)</span>. If the independent variable, <span class="math notranslate nohighlight">\(t\)</span>, is discretized at a sequence of N points, <span class="math notranslate nohighlight">\(t_i=t_0+i \Delta t\)</span>, where <span class="math notranslate nohighlight">\(i
= 0,1,\ldots, N\)</span> and <span class="math notranslate nohighlight">\(\Delta t= 1/N\)</span>, then we can write the three approximations as follows:</p>
<p><strong>Forward difference formula:</strong></p>
<div class="math notranslate nohighlight">
\[T^\prime(t_i) \approx \frac{T_{i+1}-T_i}{\Delta t}\]</div>
<p><strong>Backward difference formula:</strong></p>
<div class="math notranslate nohighlight">
\[T^\prime(t_i) \approx \frac{T_{i}-T_{i-1}}{\Delta t}\]</div>
<p><strong>Centered difference formula</strong> (add together the forwards and backwards formula):</p>
<div class="math notranslate nohighlight">
\[T^\prime(t_i) \approx \frac{T_{i+1}-T_{i-1}}{2 \Delta t}\]</div>
<p>In fact, there are many other possible methods to approximate the derivative (some of which we will see later in this Lab). With this large choice we have in the choice of approximation scheme, it is not at all clear at this point which, if any, of the schemes is the “best”. It is the purpose of this Lab to present you with some basic tools that will help you to decide on an appropriate discretization for a given problem. There is no generic “best” method, and the choice of discretization will
always depend on the problem that is being dealt with.</p>
<p>In an example from Lab #1, the forward difference formula was used to compute solutions to the saturation development equation, and you saw two important results:</p>
<ul class="simple">
<li><p>reducing the grid spacing, <span class="math notranslate nohighlight">\(\Delta t\)</span>, seemed to improve the accuracy of the approximate solution; and</p></li>
<li><p>if <span class="math notranslate nohighlight">\(\Delta t\)</span> was taken too large (that is, the grid was not fine enough), then the approximate solution exhibited non-physical oscillations, or a <em>numerical instability</em>.</p></li>
</ul>
<p>There are several questions that arise from this example:</p>
<ol class="arabic simple">
<li><p>Is it always true that reducing <span class="math notranslate nohighlight">\(\Delta t\)</span> will improve the discrete solution?</p></li>
<li><p>Is it possible to improve the accuracy by using another approximation scheme (such as one based on the backward or centered difference formulas)?</p></li>
<li><p>Are these numerical instabilities something that always appear when the grid spacing is too large?</p></li>
<li><p>By using another difference formula for the first derivative, is it possible to improve the stability of the approximate solution, or to eliminate the stability altogether?</p></li>
</ol>
<p>The first two questions, related to <em>accuracy</em>, will be dealt with in the next section, Section 5 (1.5), and the last two will have to wait until Section 6 (1.6) when <em>stability</em> is discussed.</p>
</section>
<section id="Accuracy-of-Difference-Approximations">
<h2>Accuracy of Difference Approximations<a class="headerlink" href="#Accuracy-of-Difference-Approximations" title="Link to this heading">¶</a></h2>
<p>Before moving on to the details of how to measure the error in a scheme, let’s take a closer look at another example which we’ve seen already …</p>
<section id="Accuracy-Example">
<h3>Accuracy Example<a class="headerlink" href="#Accuracy-Example" title="Link to this heading">¶</a></h3>
<p>Let’s go back to the heat conduction equation from Lab #1, where the temperature, <span class="math notranslate nohighlight">\(T(t)\)</span>, of a rock immersed in water or air, evolves in time according to the first order ODE:</p>
<div class="math notranslate nohighlight">
\[\frac{dT}{dt} = \lambda(T,t) \, (T-T_a)\]</div>
<p>with initial condition <span class="math notranslate nohighlight">\(T(0)\)</span>. We saw in the section on the <strong>forward Euler method</strong> that one way to discretize this equation was using the forward difference formula  for the derivative, leading to</p>
<p><span class="math notranslate nohighlight">\(T_{i+1} = T_i + \Delta t \, \lambda(T_i,t_i) \, (T_i-T_a).\)</span> (<strong>eq: euler</strong>)</p>
<p>Similarly, we could apply either of the other two difference formulae to obtain other difference schemes, namely what we called the <strong>backward Euler method</strong></p>
<p><span class="math notranslate nohighlight">\(T_{i+1} = T_i + \Delta t \, \lambda(T_{i+1},t_{i+1}) \, (T_{i+1}-T_a),\)</span> (<strong>eq: beuler</strong>)</p>
<p>and the <strong>mid-point</strong> or <strong>leap-frog</strong> centered method</p>
<p><span class="math notranslate nohighlight">\(T_{i+1} = T_{i-1} + 2 \Delta t \, \lambda(T_{i},t_{i}) \, (T_{i}-T_a).\)</span> (<strong>eq: midpoint</strong>)</p>
<p>The forward Euler and mid-point schemes are called <em>explicit methods</em>, since they allow the temperature at any new time to be computed in terms of the solution values at <em>previous</em> time steps only, i.e. it does not require any information from current or future time steps. The backward Euler scheme, on the other hand, is called an <em>implicit scheme</em>, since it gives an equation defining <span class="math notranslate nohighlight">\(T_{i+1}\)</span> implicitly, that is, the function <span class="math notranslate nohighlight">\(\lambda\)</span> takes the value <span class="math notranslate nohighlight">\(T_{i+1}\)</span> as an input,
in order to calculate <span class="math notranslate nohighlight">\(T_{i+1}\)</span>. If <span class="math notranslate nohighlight">\(\lambda\)</span> depends non-linearly on <span class="math notranslate nohighlight">\(T\)</span>, then this equation may require an additional step, involving the iterative solution of a non-linear equation. We will pass over this case for now, and refer you to a reference such as Burden and Faires (1981) for the details on non-linear solvers such as <em>Newton’s method</em>.</p>
<p><strong>Important point</strong>: Note that <strong>eq: midpoint</strong> requires the value of the temperature at two points: <span class="math notranslate nohighlight">\(T_{i-1}\)</span> and <span class="math notranslate nohighlight">\(T_{i}\)</span> to calculate the temperature <span class="math notranslate nohighlight">\(T_{i+1}\)</span>. This requires an approximate guess for <span class="math notranslate nohighlight">\(T_i\)</span>, which we will discuss in more detail below.</p>
<p>For now, let’s assume that the function <span class="math notranslate nohighlight">\(\lambda\)</span> is a constant, and thus it is independent of <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(t\)</span>. Plots of the numerical results from each of these schemes, along with the exact solution, are given in Figure 1 (with the “unphysical” parameter value <span class="math notranslate nohighlight">\(\lambda=0.8\)</span> chosen to enhance the show the growth of numerical errors, even though in a real material this would violate conservation of energy).</p>
<p>The functions used in make the following figure are imported from <a class="reference external" href="https://github.com/rhwhite/numeric_2024/blob/main/numlabs/lab2/lab2_functions.py">lab2_functions.py</a></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># import and define functions</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span><span class="w"> </span><span class="nn">context</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numlabs.lab2.lab2_functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">euler</span><span class="p">,</span><span class="n">beuler</span><span class="p">,</span><span class="n">leapfrog</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;ggplot&#39;</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># save our three functions to a dictionary, keyed by their names</span>
<span class="c1">#</span>
<span class="n">theFuncs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;euler&#39;</span><span class="p">:</span><span class="n">euler</span><span class="p">,</span><span class="s1">&#39;beuler&#39;</span><span class="p">:</span><span class="n">beuler</span><span class="p">,</span><span class="s1">&#39;leapfrog&#39;</span><span class="p">:</span><span class="n">leapfrog</span><span class="p">}</span>
<span class="c1">#</span>
<span class="c1"># store the results in another dictionary</span>
<span class="c1">#</span>
<span class="n">output</span><span class="o">=</span><span class="p">{}</span>
<span class="c1">#</span>
<span class="c1">#end time = 10 seconds</span>
<span class="c1">#</span>
<span class="n">tend</span><span class="o">=</span><span class="mf">10.</span>
<span class="c1">#</span>
<span class="c1"># start at 30 degC, air temp of 20 deg C</span>
<span class="c1">#</span>
<span class="n">Ta</span><span class="o">=</span><span class="mf">20.</span>
<span class="n">To</span><span class="o">=</span><span class="mf">30.</span>
<span class="c1">#</span>
<span class="c1"># note that lambda is a reserved keyword in python so call this</span>
<span class="c1"># thelambda</span>
<span class="c1">#</span>
<span class="n">theLambda</span><span class="o">=</span><span class="mf">0.8</span>  <span class="c1">#units have to be per minute if time in seconds</span>
<span class="c1">#</span>
<span class="c1"># dt = 10/npts = 10/30 = 1/3</span>
<span class="c1">#</span>
<span class="n">npts</span><span class="o">=</span><span class="mi">30</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">the_fun</span> <span class="ow">in</span> <span class="n">theFuncs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">output</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">the_fun</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span><span class="n">tend</span><span class="p">,</span><span class="n">To</span><span class="p">,</span><span class="n">Ta</span><span class="p">,</span><span class="n">theLambda</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># calculate the exact solution for comparison</span>
<span class="c1">#</span>
<span class="n">exactTime</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tend</span><span class="p">,</span><span class="n">npts</span><span class="p">)</span>
<span class="n">exactTemp</span><span class="o">=</span><span class="n">Ta</span> <span class="o">+</span> <span class="p">(</span><span class="n">To</span><span class="o">-</span><span class="n">Ta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">theLambda</span><span class="o">*</span><span class="n">exactTime</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># now plot all four curves</span>
<span class="c1">#</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">exactTime</span><span class="p">,</span><span class="n">exactTemp</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">fun_name</span> <span class="ow">in</span> <span class="n">output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">the_time</span><span class="p">,</span><span class="n">the_temp</span><span class="o">=</span><span class="n">output</span><span class="p">[</span><span class="n">fun_name</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">the_time</span><span class="p">,</span><span class="n">the_temp</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">fun_name</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">30.</span><span class="p">,</span><span class="mf">90.</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;time (seconds)&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;bar temp (deg C)&#39;</span><span class="p">)</span>
<span class="n">out</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><strong>Figure 1</strong> A plot of the exact and computed solutions for the temperature of a rock, with parameters: <span class="math notranslate nohighlight">\(T_a=20\)</span>, <span class="math notranslate nohighlight">\(T(0)=30\)</span>, <span class="math notranslate nohighlight">\(\lambda= +0.8\)</span>, <span class="math notranslate nohighlight">\(\Delta t=\frac{1}{3}\)</span></p>
<p>Notice from these results that the mid-point/leap-frog scheme is the most accurate, and backward Euler the least accurate.</p>
<p>The next section explains why some schemes are more accurate than others, and introduces a means to quantify the accuracy of a numerical approximation.</p>
</section>
<section id="Round-off-Error-and-Discretization-Error">
<h3>Round-off Error and Discretization Error<a class="headerlink" href="#Round-off-Error-and-Discretization-Error" title="Link to this heading">¶</a></h3>
<p>From Accuracy Example and the example in the Forward Euler section of the previous lab,  it is obvious that a numerical approximation is exactly that - <strong>an approximation</strong>. The process of discretizing a differential equation inevitably leads to errors. In this section, we will tackle two fundamental questions related to the accuracy of a numerical approximation:</p>
<ul class="simple">
<li><p>Where does the error come from (and how can we measure it)?</p></li>
<li><p>How can the error be controlled?</p></li>
</ul>
</section>
<section id="Where-does-the-error-come-from?">
<h3>Where does the error come from?<a class="headerlink" href="#Where-does-the-error-come-from?" title="Link to this heading">¶</a></h3>
<section id="Round-off-error:">
<h4>Round-off error:<a class="headerlink" href="#Round-off-error:" title="Link to this heading">¶</a></h4>
<p>When attempting to solve differential equations on a computer, there are two main sources of error. The first, <em>round-off error</em>, derives from the fact that a computer can only represent real numbers by <em>floating point</em> approximations, which have only a finite number of digits of accuracy.</p>
<ul class="simple">
<li><p>Mathematical note floating point notation</p></li>
</ul>
<p>For example, we all know that the number <span class="math notranslate nohighlight">\(\pi\)</span> is a non-repeating decimal, which to the first twenty significant digits is <span class="math notranslate nohighlight">\(3.1415926535897932385\dots\)</span> Imagine a computer which stores only eight significant digits, so that the value of <span class="math notranslate nohighlight">\(\pi\)</span> is rounded to <span class="math notranslate nohighlight">\(3.1415927\)</span>.</p>
<p>In many situations, these five digits of accuracy may be sufficient. However, in some cases, the results can be catastrophic, as shown in the following example:</p>
<div class="math notranslate nohighlight">
\[\frac{\pi}{(\pi + 0.00000001)-\pi}.\]</div>
<p>Since the computer can only “see” 8 significant digits, the addition <span class="math notranslate nohighlight">\(\pi+0.00000001\)</span> is simply equal to <span class="math notranslate nohighlight">\(\pi\)</span> as far as the computer is concerned. Hence, the computed result is <span class="math notranslate nohighlight">\(\frac{1}{0}\)</span> - an undefined expression! The exact answer <span class="math notranslate nohighlight">\(100000000\pi\)</span>, however, is a very well-defined non-zero value.</p>
<p>A side note: round-off errors played a key role in Edward Lorenz’s exploration of chaos theory in physics, see <a class="reference external" href="https://www.aps.org/publications/apsnews/200301/history.cfm">https://www.aps.org/publications/apsnews/200301/history.cfm</a></p>
</section>
<section id="Truncation-error:">
<h4>Truncation error:<a class="headerlink" href="#Truncation-error:" title="Link to this heading">¶</a></h4>
<p>The second source of error stems from the discretization of the problem, and hence is called <em>discretization error</em> or <em>truncation error</em>. In comparison, round-off error is always present, and is independent of the discretization being used. The simplest and most common way to analyse the truncation error in a scheme is using <em>Taylor series expansions</em>.</p>
<p>Let us begin with the forward difference formula for the first derivative, , which involves the discrete solution at times <span class="math notranslate nohighlight">\(t_{i+1}\)</span> and <span class="math notranslate nohighlight">\(t_{i}\)</span>. Since only continuous functions can be written as Taylor series, we expand the exact solution (instead of the discrete values <span class="math notranslate nohighlight">\(T_i\)</span>) at the discrete point <span class="math notranslate nohighlight">\(t_{i+1}\)</span>:</p>
<div class="math notranslate nohighlight">
\[T(t_{i+1}) = T(t_i+\Delta t) = T(t_i) + (\Delta t) T^\prime(t_i) +
  \frac{1}{2}(\Delta t)^2 T^{\prime\prime}(t_i) +\cdots\]</div>
<p>Rewriting to clean this up slightly gives <strong>eq: feuler</strong></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
T(t_{i+1}) &amp;= T(t_i) + \Delta t T^{\prime}(t_i,T(t_i)) +
  \underbrace{\frac{1}{2}(\Delta t)^2T^{\prime\prime}(t_i) + \cdots}
_{\mbox{ truncation error}} \\ \;
  &amp;= T(t_i) + \Delta t T^{\prime}(t_i) + {\cal O}(\Delta t^2).
 \end{aligned}\end{split}\]</div>
<p>This second expression writes the truncation error term in terms of <em>order notation</em>. If we write <span class="math notranslate nohighlight">\(y = {\cal O}(\Delta t)\)</span>, then we mean simply that <span class="math notranslate nohighlight">\(y &lt; c \cdot \Delta t\)</span> for some constant <span class="math notranslate nohighlight">\(c\)</span>, and we say that “ <span class="math notranslate nohighlight">\(y\)</span> is first order in <span class="math notranslate nohighlight">\(\Delta t\)</span> ” (since it depends on <span class="math notranslate nohighlight">\(\Delta t\)</span> to the first power) or “ <span class="math notranslate nohighlight">\(y\)</span> is big-oh of <span class="math notranslate nohighlight">\(\Delta t\)</span>.” As <span class="math notranslate nohighlight">\(\Delta t\)</span> is assumed small, the next term in the series, <span class="math notranslate nohighlight">\(\Delta t^2\)</span> is small compared to the
<span class="math notranslate nohighlight">\(\Delta t\)</span> term. In words, we say that forward euler is <em>first order accurate</em> with errors of second order.</p>
<p>It is clear from this that as <span class="math notranslate nohighlight">\(\Delta t\)</span> is reduced in size (as the computational grid is refined), the error is also reduced. If you remember that we derived the approximation from the limit definition of derivative, then this should make sense. This dependence of the error on powers of the grid spacing <span class="math notranslate nohighlight">\(\Delta t\)</span> is an underlying characteristic of difference approximations, and we will see approximations with higher orders in the coming sections …</p>
<p>There is one more important distinction to be made here. The “truncation error” we have been discussing so far is actually what is called <em>local truncation error</em>. It is “local” in the sense that we have expanded the Taylor series <em>locally</em> about the exact solution at the point <span class="math notranslate nohighlight">\(t_i\)</span>.</p>
<p>There is also a <em>global truncation error</em> (or, simply, <em>global error</em>), which is the error made during the course of the entire computation, from time <span class="math notranslate nohighlight">\(t_0\)</span> to time <span class="math notranslate nohighlight">\(t_n\)</span>. The difference between local and global truncation error is illustrated in Figure 2. If the local error stays approximately constant, then the global error will be approximately the local error times the number of timesteps. For a fixed simulation length of <span class="math notranslate nohighlight">\(t\)</span>, the number of timesteps required is
<span class="math notranslate nohighlight">\(t/\Delta t\)</span>, thus the global truncation error will be approximately of the order of <span class="math notranslate nohighlight">\(1/\Delta t\)</span> times the local error, or about one order of <span class="math notranslate nohighlight">\(\Delta t\)</span> <em>worse</em> (lower order) than the local error.</p>
<p><img alt="4fb890a5808743369bd6adb263a2379e" src="../../_images/error.png" /></p>
<p><strong>Figure Error:</strong> Local and global truncation error.</p>
<p>It is easy to get a handle on the order of the local truncation error using Taylor series, regardless of whether the exact solution is known, but no similar analysis is available for the global error. We can write</p>
<div class="math notranslate nohighlight">
\[\text{global error} = |T(t_n)-T_n|\]</div>
<p>but this expression can only be evaluated if the exact solution is known ahead of time (which is not the case in most problems we want to compute, since otherwise we wouldn’t be computing it in the first place!). Therefore, when we refer to truncation error, we will always be referring to the local truncation error.</p>
</section>
<section id="Second-order-accuracy">
<h4>Second order accuracy<a class="headerlink" href="#Second-order-accuracy" title="Link to this heading">¶</a></h4>
<p>Above we mentioned a problem with evaluating the mid-point method. If we start with three points <span class="math notranslate nohighlight">\((t_0,t_1,t_2)\)</span>, each separated by <span class="math notranslate nohighlight">\(\Delta t/2\)</span> so that <span class="math notranslate nohighlight">\(t_2 - t_0=\Delta t\)</span></p>
<p><span class="math">\begin{align}
y(t_2)&=y(t_1) + y^\prime (t_1,y(t_1))(t_2 - t_1) + \frac{y^{\prime \prime}(t_1,y(t_1))}{2} (t_2 - t_1)^2 + \frac{y^{\prime \prime \prime}(t_1,y(t_1))}{6} (t_2 - t_1)^3 + h.o.t. \ (eq.\ a)\\
y(t_0)&=y(t_1) + y^\prime (t_1,y(t_1))(t_0 - t_1) + \frac{y^{\prime \prime}(t_1)}{2} (t_0 - t_1)^2 + \frac{y^{\prime \prime \prime}(t_1)}{6} (t_0 - t_1)^3 + h.o.t. \ (eq.\ b)
\end{align}</span></p>
<p>where h.o.t. stands for “higher order terms”. Rewriting in terms of <span class="math notranslate nohighlight">\(\Delta t\)</span>:</p>
<p><span class="math">\begin{align}
y(t_2)&=y(t_1) + \frac{\Delta t}{2}y^\prime (t_1,y(t_1)) + \frac{\Delta t^2}{8} y^{\prime \prime}(t_1,y(t_1)) + \frac{\Delta t^3}{48} y^{\prime \prime \prime}(t_1,y(t_1)) + h.o.t. \ (eq.\ a)\\
y(t_0)&=y(t_1) - \frac{\Delta t}{2}y^\prime (t_1,y(t_1)) + \frac{\Delta t^2}{8} y^{\prime \prime}(t_1,y(t_1)) - \frac{\Delta t^3}{48} y^{\prime \prime \prime}(t_1,y(t_1)) + h.o.t. \ (eq.\ b)
\end{align}</span></p>
<p>and subtracting:</p>
<p><span class="math">\begin{align}
y(t_2)&=y(t_0) + \Delta t y^\prime (t_1,y(t_1))  + \frac{\Delta t^3}{24} y^{\prime \prime \prime}(t_1,y(t_1)) + h.o.t. \ (eq.\ c)
\end{align}</span></p>
<p>where <span class="math notranslate nohighlight">\(t_1=t_0 + \Delta t/2\)</span></p>
<p>Comparing with eq: feuler we can see that we’ve canceled the <span class="math notranslate nohighlight">\(\Delta t^2\)</span> terms, so that if we drop the <span class="math notranslate nohighlight">\(\frac{\Delta t^3}{24} y^{\prime \prime \prime}(t_1,y(t_1))\)</span> and higher order terms we’re doing one order better that foward euler, as long as we can solve the problem of estimating y at the midpoint: <span class="math notranslate nohighlight">\(y(t_1) = y(t_0 + \Delta t/2)\)</span></p>
</section>
<section id="Mid-point-and-leap-frog">
<h4>Mid-point and leap-frog<a class="headerlink" href="#Mid-point-and-leap-frog" title="Link to this heading">¶</a></h4>
<div class="line-block">
<div class="line">The mid-point and leap-frog methods take two slightly different approaches to estimating <span class="math notranslate nohighlight">\(y(t_0 + \Delta t/2)\)</span>.</div>
<div class="line">For the <a class="reference external" href="https://en.wikipedia.org/wiki/Midpoint_method">explicit mid-point method</a>, we estimate <span class="math notranslate nohighlight">\(y\)</span> at the midpoint by taking a half-step:</div>
</div>
<p><span class="math">\begin{align}
k_1 & = \Delta t y^\prime(t_0,y(t_0)) \\
k_2 & = \Delta t y^\prime(t_0 + \Delta t/2,y(t_0) + k_1/2) \\
y(t_0 + \Delta t) &= y(t_0) + k_2
\end{align}</span></p>
<p>Compare this to the <a class="reference external" href="https://en.wikipedia.org/wiki/Leapfrog_integration">leap-frog method</a>, which uses the results from one half-interval to calculate the results for the next half-interval:</p>
<p><span class="math">\begin{align}
y(t_0 + \Delta t/2)  & = y(t_0) + \frac{\Delta t}{2} y^\prime(t_0,y(t_0))\ (i) \\
y(t_0 + \Delta t) & = y(t_0) + \Delta t y^\prime(t_0 + \Delta t/2,y(t_0 + \Delta t/2)\ (ii)\\
y(t_0 + 3 \Delta t/2)  & = y(t_0 + \Delta t/2) + \Delta t y^\prime(t_0 + \Delta t,y(t_0 + \Delta t))\ (iii) \\
y(t_0 + 2 \Delta t)  & = y(t_0 + \Delta t) + \Delta t y^\prime(t_0 + 3\Delta t/2,y(t_0 + 3 \Delta t/2))\ (iv) \\
\end{align}</span></p>
<p>Comparing (iii) and (iv) shows how the method gets its name: the half-interval and whole interval values are calculated by leaping over each other. Once the first half and whole steps are done, the rest of the integration is completed by repeating (iii) and (iv) as until the endpoint is reached.</p>
<p>The leap-frog scheme has the advantage that it is <em>time reversible</em> or as the Wikipedia article says <em>sympletic</em>. This means that estimating <span class="math notranslate nohighlight">\(y(t_1)\)</span> and then using that value to go backwards by <span class="math notranslate nohighlight">\(-\Delta t\)</span> yields <span class="math notranslate nohighlight">\(y(t_0)\)</span> exactly, which the mid-point method does not. The mid-point method, however, is one member (the 2nd order member) of a family of <em>Runge Kutta</em> integrators, which will be covered in more detail in Lab 4.</p>
</section>
</section>
<section id="How-can-we-control-the-error?">
<h3>How can we control the error?<a class="headerlink" href="#How-can-we-control-the-error?" title="Link to this heading">¶</a></h3>
<p>Now that we’ve determined the source of the error in numerical methods, we would like to find a way to control it; that is, we would like to be able to compute and be confident that our approximate solution is “close” to the exact solution. Round-off error is intrinsic to all numerical computations, and cannot be controlled (except to develop methods that do not magnify the error unduly … more on this later). Truncation error, on the other hand, <em>is</em> under our control.</p>
<p>In the simple ODE examples that we’re dealing with in this lab, the round-off error in a calculation is much smaller than the truncation error. Furthermore, the schemes being used are <em>stable with respect to round-off error</em> in the sense that round-off errors are not magnified in the course of a computation. So, we will restrict our discussion of error control in what follows to the truncation error.</p>
<p>However, there are many numerical algorithms in which the round-off error can dominate the the result of a computation (Gaussian elimination is one example, which you will see in Lab #3 ), and so we must always keep it in mind when doing numerical computations.</p>
<p>There are two fundamental ways in which the truncation error in an approximation  can be reduced:</p>
<ol class="arabic simple">
<li><p><strong>Decrease the grid spacing</strong>. Provided that the second derivative of the solution is bounded, it is clear from the error term in <strong>eq: feuler</strong> that as <span class="math notranslate nohighlight">\(\Delta t\)</span> is reduced, the error will also get smaller. This principle was demonstrated in an example from Lab #1 using the Forward Euler method. The disadvantage to decreasing <span class="math notranslate nohighlight">\(\Delta t\)</span> is that the cost of the computation increases since more steps must be taken. Also, there is a limit to how small <span class="math notranslate nohighlight">\(\Delta t\)</span> can be,
beyond which round-off errors will start polluting the computation.</p></li>
<li><p><strong>Increase the order of the approximation</strong>. We saw above that the forward difference approximation of the first derivative is first order accurate in the grid spacing. It is also possible to derive higher order difference formulas which have a leading error term of the form <span class="math notranslate nohighlight">\((\Delta t)^p\)</span>, with <span class="math notranslate nohighlight">\(p&gt;1\)</span>. As noted above in Section Second Order the midpoint formula is a second order scheme, and some further examples will be given in Section Higher order
Taylor. The main disadvantage to using very high order schemes is that the error term depends on higher derivatives of the solution, which can sometimes be very large – in this case, the stability of the scheme can be adversely affected (for more on this, see Section Stability.</p></li>
</ol>
</section>
<section id="Problem-Accuracy">
<h3>Problem Accuracy<a class="headerlink" href="#Problem-Accuracy" title="Link to this heading">¶</a></h3>
<p>In order to investigate these two approaches to improving the accuracy of an approximation, you can use the code in <a class="reference external" href="https://github.com/rhwhite/numeric_2024/blob/main/numlabs/lab2/terror2.ipynb">terror.ipynb</a> to play with the solutions to the heat conduction equation. You will need the additional functions provided for this lab. These can be found on your local computer: numeric_2024/numlabs/lab2 (you will need to fetch upstream from github to get recent changes from our version to your clone
before pulling those changes to your local machine; don’t forget to commit your previous labs!). For a given function <span class="math notranslate nohighlight">\(\lambda(T)\)</span>, and specified parameter values, you should experiment with various time steps and schemes, and compare the computed results (Note: only the answers to the assigned questions need to be handed in). Look at the different schemes (euler, leap-frog, midpoint, 4th order runge kutta) run them for various total times (tend) and step sizes (dt=tend/npts).</p>
<p>The three schemes that will be used here are forward Euler (first order), leap-frog (second order) and the fourth order Runge-Kutta scheme (which will be introduced more thoroughly in Lab 4).</p>
<p>Try three different step sizes for all three schemes for a total of 9 runs. It’s helpful to be able to change the axis limits to look at various parts of the plot.</p>
<p>Use your 9 results to answer parts a and b below.</p>
<ul class="simple">
<li><ol class="loweralpha simple">
<li><p>Does increasing the order of the scheme, or decreasing the time step always improve the solution?</p></li>
</ol>
</li>
<li><ol class="loweralpha simple" start="2">
<li><p>How would you compute the local truncation error from the error plot? And the global error? Do this on a plot for one set of parameters.</p></li>
</ol>
</li>
<li><ol class="loweralpha simple" start="3">
<li><p>Similarly, how might you estimate the <em>order</em> of the local truncation error? The order of the global error? ( <strong>Hint:</strong> An order <span class="math notranslate nohighlight">\(p\)</span> scheme has truncation error that looks like <span class="math notranslate nohighlight">\(c\cdot(\Delta t)^p\)</span>. Read the error off the plots for several values of the grid spacing and use this to find <span class="math notranslate nohighlight">\(p\)</span>.) Are the local and global error significantly different? Why or why not?</p></li>
</ol>
</li>
</ul>
</section>
<section id="Other-Approximations-to-the-First-Derivative">
<h3>Other Approximations to the First Derivative<a class="headerlink" href="#Other-Approximations-to-the-First-Derivative" title="Link to this heading">¶</a></h3>
<p>The Taylor series method of deriving difference formulae for the first derivative is the simplest, and can be used to obtain approximations with even higher order than two. There are also many other ways to discretize the derivatives appearing in ODE’s, as shown in the following sections…</p>
<section id="Higher-Order-Taylor-Methods">
<h4>Higher Order Taylor Methods<a class="headerlink" href="#Higher-Order-Taylor-Methods" title="Link to this heading">¶</a></h4>
<p>As mentioned earlier, there are many other possible approximations to the first derivative using the Taylor series approach. The basic approach in these methods is as follows:</p>
<ol class="arabic simple">
<li><p>expand the solution in a Taylor series at one or more points surrounding the point where the derivative is to be approximated (for example, for the centered scheme, you used two points, <span class="math notranslate nohighlight">\(T(t_i+\Delta t)\)</span> and <span class="math notranslate nohighlight">\(T(t_i-\Delta t)\)</span>. You also have to make sure that you expand the series to a high enough order …</p></li>
<li><p>take combinations of the equations until the <span class="math notranslate nohighlight">\(T_i\)</span> (and possibly some other derivative) terms are eliminated, and all you’re left with is the first derivative term.</p></li>
</ol>
<p>One example is the fourth-order centered difference formula for the first derivative:</p>
<div class="math notranslate nohighlight">
\[\frac{-T(t_{i+2})+8T(t_{i+1})-8T(t_{i-1})+T(t_{i-2})}{12\Delta t} =
  T^\prime(t_i) + {\cal O}((\Delta t)^4)\]</div>
<p><strong>Quiz:</strong> Try the quiz at <a class="reference external" href="https://phaustin.github.io/numeric/quizzes2/order.html">this link</a> related to this higher order scheme.</p>
</section>
<section id="Predictor-Corrector-Methods">
<h4>Predictor-Corrector Methods<a class="headerlink" href="#Predictor-Corrector-Methods" title="Link to this heading">¶</a></h4>
<p>Another class of discretizations are called <em>predictor-corrector methods</em>. Implicit methods can be difficult or expensive to use because of the solution step, and so they are seldom used to integrate ODE’s. Rather, they are often used as the basis for predictor-corrector algorithms, in which a “prediction” for <span class="math notranslate nohighlight">\(T_{i+1}\)</span> based only on an explicit method is then “corrected” to give a better value by using this precision in an implicit method.</p>
<p>To see the basic idea behind these methods, let’s go back (once again) to the backward Euler method for the heat conduction problem which reads:</p>
<div class="math notranslate nohighlight">
\[T_{i+1} = T_{i} + \Delta t \, \lambda( T_{i+1}, t_{i+1} ) \, ( T_{i+1}
- T_a ).\]</div>
<p>Note that after applying the backward difference formula , all terms in the right hand side are evaluated at time <span class="math notranslate nohighlight">\(t_{i+1}\)</span>.</p>
<p>Now, <span class="math notranslate nohighlight">\(T_{i+1}\)</span> is defined implicitly in terms of itself, and unless <span class="math notranslate nohighlight">\(\lambda\)</span> is a very simple function, it may be very difficult to solve this equation for the value of <span class="math notranslate nohighlight">\(T\)</span> at each time step. One alternative, mentioned already, is the use of a non-linear equation solver such as Newton’s method to solve this equation. However, this is an iterative scheme, and can lead to a lot of extra expense. A cheaper alternative is to realize that we could try estimating or <em>predicting</em> the
value of <span class="math notranslate nohighlight">\(T_{i+1}\)</span> using the simple explicit forward Euler formula and then use this in the right hand side, to obtain a <em>corrected</em> value of <span class="math notranslate nohighlight">\(T_{i+1}\)</span>. The resulting scheme,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
  \mathbf{Prediction}: &amp; \widetilde{T}_{i+1} = T_i + \Delta t \,
  \lambda(T_i,t_i) \, (T_i-T_a), \\ \; \\
  \mathbf{Correction}: &amp; T_{i+1} = T_i + \Delta t \,
  \lambda(\widetilde{T}_{i+1},t_{i+1}) \, (\widetilde{T}_{i+1}-T_a).
\end{array}\end{split}\]</div>
<p>This method is an explicit scheme, which can also be shown to be second order accurate in . It is the simplest in a whole class of schemes called <em>predictor-corrector schemes</em> (more information is available on these methods in a numerical analysis book such as  &#64;burden-faires).</p>
</section>
<section id="Other-Methods">
<h4>Other Methods<a class="headerlink" href="#Other-Methods" title="Link to this heading">¶</a></h4>
<p>The choice of methods is made even greater by two other classes of schemes:</p>
<p><strong>Runge-Kutta methods:</strong></p>
<ul class="simple">
<li><p>We have already seen two examples of the Runge-Kutta family of integrators: Forward Euler is a first order Runge-Kutta, and the midpoint method is second order Runge-Kutta. Fourth and fifth order Runge-Kutta algorithms will be described in Labs #4 and #5</p></li>
</ul>
<p><strong>Multi-step methods:</strong></p>
<ul class="simple">
<li><p>These use values of the solution at more than one previous time step in order to increase the accuracy. Compare these to one-step schemes, such as forward Euler, which use the solution only at one previous step.</p></li>
</ul>
<p>More can be found on these (and other) methods in  Burden and Faires (1981) and Newman (2013)</p>
</section>
</section>
<section id="Accuracy-Summary">
<h3>Accuracy Summary<a class="headerlink" href="#Accuracy-Summary" title="Link to this heading">¶</a></h3>
<p>In this section, you’ve been given a short overview of the accuracy of difference schemes for first order ordinary differential equations. We’ve seen that accuracy can be improved by either decreasing the grid spacing, or by choosing a higher order scheme from one of several classes of methods. When using a higher order scheme, it is important to realize that the cost of the computation usually rises due to an added number of function evaluations (especially for multi-step and Runge-Kutta
methods). When selecting a numerical scheme, it is important to keep in mind this trade-off between accuracy and cost.</p>
<p>However, there is another important aspect of discretization that we have pretty much ignored. The next section will take a look at schemes of various orders from a different light, namely that of <em>stability</em>.</p>
</section>
</section>
<section id="Stability-of-Difference-Approximations">
<h2>Stability of Difference Approximations<a class="headerlink" href="#Stability-of-Difference-Approximations" title="Link to this heading">¶</a></h2>
<p>The easiest way to introduce the concept of stability is for you to see it yourself.</p>
<section id="Problem-Stability">
<h3>Problem Stability<a class="headerlink" href="#Problem-Stability" title="Link to this heading">¶</a></h3>
<p>This example is a slight modification of <a class="reference internal" href="#Problem-Accuracy"><span class="std std-ref">Problem accuracy</span></a> from the previous section on accuracy. We will add one scheme (backward euler) and drop the 4th order Runge-Kutta, and change the focus from error to stability. The value of <span class="math notranslate nohighlight">\(\lambda\)</span> is assumed a constant, so that the backward Euler scheme results in an explicit method, and we’ll also compute a bit further in time, so that any instability manifests itself more clearly. Run the
<a class="reference external" href="https://github.com/rhwhite/numeric_2024/blob/main/numlabs/lab2/stability2.ipynb">stability2.ipynb</a> notebook in numlabs/lab2 with <span class="math notranslate nohighlight">\(\lambda= -8\ s^{-1}\)</span>, with <span class="math notranslate nohighlight">\(\Delta t\)</span> values that just straddle the stability condition for the forward euler scheme (<span class="math notranslate nohighlight">\(\Delta t &lt; \frac{-2}{\lambda}\)</span>, derived below). Create plots that show that</p>
<ol class="arabic simple">
<li><p>the stability condition does in fact predict the onset of the instablity in the euler scheme, and</p></li>
<li><p>determine whether the backward euler and leap-frog are stable or unstable for the same <span class="math notranslate nohighlight">\(\Delta t\)</span> values. (you should run out to longer than tend=10 seconds to see if there is a delayed instability.)</p></li>
</ol>
<p>and provide comments/markdown code explaining what you see in the plots.</p>
</section>
<section id="Determining-Stability-Properties">
<h3>Determining Stability Properties<a class="headerlink" href="#Determining-Stability-Properties" title="Link to this heading">¶</a></h3>
<p>The heat conduction problem, as you saw in Lab #1, has solutions that are stable when <span class="math notranslate nohighlight">\(\lambda&lt;0\)</span>. It is clear from <a class="reference internal" href="#Problem-Stability"><span class="std std-ref">Problem stability</span></a> above that some higher order schemes (namely, the leap-frog scheme) introduce a spurious oscillation not present in the continuous solution. This is called a <em>computational</em> or <em>numerical instability</em>, because it is an artifact of the discretization process only. This instability is not a characteristic of the heat conduction problem
alone, but is present in other problems where such schemes are used. Furthermore, as we will see below, even a scheme such as forward Euler can be unstable for certain problems and choices of the time step.</p>
<p>There is a way to determine the stability properties of a scheme, and that is to apply the scheme to the <em>test equation</em></p>
<div class="math notranslate nohighlight">
\[\frac{dz}{dt} = \lambda z\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is a complex constant.</p>
<p>The reason for using this equation may not seem very clear. But if you think in terms of <span class="math notranslate nohighlight">\(\lambda z\)</span> as being the linearization of some more complex right hand side, then the solution to is <span class="math notranslate nohighlight">\(z=e^{\lambda t}\)</span>, and so <span class="math notranslate nohighlight">\(z\)</span> represents, in some sense, a Fourier mode of the solution to the linearized ODE problem. We expect that the behaviour of the simpler, linearized problem should mimic that of the original problem.</p>
<p>Applying the forward Euler scheme to this test equation, results in the following difference formula</p>
<div class="math notranslate nohighlight">
\[z_{i+1} = z_i+(\lambda \Delta t)z_i\]</div>
<p>which is a formula that we can apply iteratively to <span class="math notranslate nohighlight">\(z_i\)</span> to obtain</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
z_{i+1} &amp;=&amp; (1+\lambda \Delta t)z_{i} \\
        &amp;=&amp; (1+\lambda \Delta t)^2 z_{i-1} \\
        &amp;=&amp; \cdots \\
        &amp;=&amp; (1+\lambda \Delta t)^{i+1} z_{0}.\end{aligned}\end{split}\]</div>
<p>The value of <span class="math notranslate nohighlight">\(z_0\)</span> is fixed by the initial conditions, and so this difference equation for <span class="math notranslate nohighlight">\(z_{i+1}\)</span> will “blow up” as <span class="math notranslate nohighlight">\(i\)</span> gets bigger, if the factor in front of <span class="math notranslate nohighlight">\(z_0\)</span> is greater than 1 in magnitude – this is a sign of instability. Hence, this analysis has led us to the conclusion that if</p>
<div class="math notranslate nohighlight">
\[|1+\lambda\Delta t| &lt; 1,\]</div>
<p>then the forward Euler method is stable. For <em>real</em> values of <span class="math notranslate nohighlight">\(\lambda&lt;0\)</span>, this inequality can be shown to be equivalent to the <em>stability condition</em></p>
<div class="math notranslate nohighlight">
\[\Delta t &lt; \frac{-2}{\lambda},\]</div>
<p>which is a restriction on how large the time step can be so that the numerical solution is stable.</p>
</section>
<section id="Problem-Backward-Euler">
<h3>Problem Backward Euler<a class="headerlink" href="#Problem-Backward-Euler" title="Link to this heading">¶</a></h3>
<p>Perform a similar analysis for the backward Euler formula, and show that it is <em>always stable</em> when <span class="math notranslate nohighlight">\(\lambda\)</span> is real and negative. Confirm this using plots using similar code to Problem: Stability (i.e. using stability2.ipynb if you haven’t gone through Problem: Stability yet)</p>
</section>
<section id="Example:-leap-frog">
<h3>Example: leap-frog<a class="headerlink" href="#Example:-leap-frog" title="Link to this heading">¶</a></h3>
<p><em>Now, what about the leap-frog scheme?</em></p>
<p>Applying the test equation to the leap-frog scheme results in the difference equation</p>
<div class="math notranslate nohighlight">
\[z_{i+1} = z_{i-1} + 2 \lambda \Delta t z_i.\]</div>
<p>Difference formulas such as this one are typically solved by looking for a solution of the form <span class="math notranslate nohighlight">\(z_i = w^i\)</span> which, when substituted into this equation, yields</p>
<div class="math notranslate nohighlight">
\[w^2 - 2\lambda\Delta t w - 1 = 0,\]</div>
<p>a quadratic equation with solution</p>
<div class="math notranslate nohighlight">
\[w = \lambda \Delta t \left[ 1 \pm \sqrt{1+\frac{1}{(\lambda
        \Delta t)^2}} \right].\]</div>
<p>The solution to the original difference equation, <span class="math notranslate nohighlight">\(z_i=w^i\)</span> is stable only if all solutions to this quadratic satisfy <span class="math notranslate nohighlight">\(|w|&lt;1\)</span>, since otherwise, <span class="math notranslate nohighlight">\(z_i\)</span> will blow up as <span class="math notranslate nohighlight">\(i\)</span> gets large.</p>
<p>The mathematical details are not important here – what is important is that there are two (possibly complex) roots to the quadratic equation for <span class="math notranslate nohighlight">\(w\)</span>, and one is <em>always</em> greater than 1 in magnitude <em>unless</em> <span class="math notranslate nohighlight">\(\lambda\)</span> is pure imaginary ( has real part equal to zero), <em>and</em> <span class="math notranslate nohighlight">\(|\lambda \Delta t|&lt;1\)</span>. For the heat conduction equation in Problem Stability (which is already of the same form as the test equation ), <span class="math notranslate nohighlight">\(\lambda\)</span> is clearly not imaginary, which
explains the presence of the instability for the leap-frog scheme.</p>
<p>Nevertheless, the leap-frog scheme is still useful for computations. In fact, it is often used in geophysical applications, as you will see later on when discretizing.</p>
<p>An example of where the leap-frog scheme is superior to the other first order schemes is for undamped periodic motion (which arose in the weather balloon example from Lab #1 ). This corresponds to the system of ordinary differential equations (with the damping parameter, <span class="math notranslate nohighlight">\(\beta\)</span>, taken to be zero):</p>
<div class="math notranslate nohighlight">
\[\frac{dy}{dt} = u,\]</div>
<div class="math notranslate nohighlight">
\[\frac{du}{dt} = - \frac{\gamma}{m} y.\]</div>
<p>You’ve already discretized this problem using the forward difference formula, and the same can be done with the second order centered formula. We can then compare the forward Euler and leap-frog schemes applied to this problem. We code this in the module</p>
<p>Solution plots are given in Figure oscilator below, for parameters <span class="math notranslate nohighlight">\(\gamma/m=1\)</span>, <span class="math notranslate nohighlight">\(\Delta t=0.25\)</span>, <span class="math notranslate nohighlight">\(y(0)=0.0\)</span> and <span class="math notranslate nohighlight">\(u(0)=1.0\)</span>, and demonstrate that the leap-frog scheme is stable, while forward Euler is unstable. This can easily be explained in terms of the stability criteria we derived for the two schemes when applied to the test equation. The undamped oscillator problem is a linear problem with pure imaginary eigenvalues, so as long as
<span class="math notranslate nohighlight">\(|\sqrt{\gamma/m}\Delta t|&lt;1\)</span>, the leap-frog scheme is stable, which is obviously true for the parameter values we are given. Furthermore, the forward Euler stability condition :math:<a href="#id1"><span class="problematic" id="id2">`</span></a><a href="#id3"><span class="problematic" id="id4">|</span></a>1+lambdaDelta</p>
<blockquote>
<div><p>t|&lt;1` is violated for any choice of time step (when <span class="math notranslate nohighlight">\(\lambda\)</span> is pure imaginary) and so this scheme is always unstable for the undamped oscillator. The github link to the oscillator module is <a class="reference external" href="https://github.com/rhwhite/numeric_2024/blob/main/numlabs/lab2/oscillator.py">oscillator.py</a></p>
</div></blockquote>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numlabs.lab2.oscillator</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">os</span>
<span class="n">the_times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">20.</span><span class="p">,</span><span class="mi">80</span><span class="p">)</span>
<span class="n">yvec_init</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">output_euler</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">euler</span><span class="p">(</span><span class="n">the_times</span><span class="p">,</span><span class="n">yvec_init</span><span class="p">)</span>
<span class="n">output_mid</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">midpoint</span><span class="p">(</span><span class="n">the_times</span><span class="p">,</span><span class="n">yvec_init</span><span class="p">)</span>
<span class="n">output_leap</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">leapfrog</span><span class="p">(</span><span class="n">the_times</span><span class="p">,</span><span class="n">yvec_init</span><span class="p">)</span>
<span class="n">answer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">the_times</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;ggplot&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">the_times</span><span class="p">,(</span><span class="n">output_euler</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="n">answer</span><span class="p">),</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;euler&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">the_times</span><span class="p">,(</span><span class="n">output_mid</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="n">answer</span><span class="p">),</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;midpoint&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">the_times</span><span class="p">,(</span><span class="n">output_leap</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="n">answer</span><span class="p">),</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;leapfrog&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">xlim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;global error between sin(t) and approx. for three schemes&#39;</span><span class="p">,</span>
      <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;exact - approx&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p><strong>Figure numerical</strong>: Numerical solution to the undamped harmonic oscillator problem, using the forward Euler and leap-frog schemes. Parameter values: <span class="math notranslate nohighlight">\(\gamma / m=1.0\)</span>, <span class="math notranslate nohighlight">\(\Delta t=0.25\)</span>, <span class="math notranslate nohighlight">\(y(0)=0\)</span>, <span class="math notranslate nohighlight">\(u(0)=1.0\)</span>. The exact solution is a sinusoidal wave.</p>
<p>Had we taken a larger time step (such as <span class="math notranslate nohighlight">\(\Delta t=2.0\)</span>, for example), then even the leap-frog scheme is unstable. Furthermore, if we add damping (<span class="math notranslate nohighlight">\(\beta\neq 0\)</span>), then the eigenvalues are no longer pure imaginary, and the leap-frog scheme is unstable no matter what time step we use.</p>
</section>
</section>
<section id="Stiff-Equations">
<h2>Stiff Equations<a class="headerlink" href="#Stiff-Equations" title="Link to this heading">¶</a></h2>
<p>This Lab has dealt only with ODE’s (and systems of ODE’s) that are <em>non-stiff</em>. <em>Stiff equations</em> are equations that have solutions with at least two widely varying times scales over which the solution changes. An example of stiff solution behaviour is a problem with solutions that have rapid, transitory oscillations, which die out over a short time scale, after which the solution slowly decays to an equilibrium. A small time step is required in the initial transitory region in order to capture
the rapid oscillations. However, a larger time step can be taken in the non-oscillatory region where the solution is smoother. Hence, using a very small time step will result in very slow and inefficient computations.</p>
<p>There are also many other numerical schemes designed specifically for stiff equations, most of which are implicit schemes. We will not describe any of them here – you can find more information in a numerical analysis text such as  &#64;burden-faires.</p>
</section>
<section id="Difference-Approximations-of-Higher-Derivatives">
<h2>Difference Approximations of Higher Derivatives<a class="headerlink" href="#Difference-Approximations-of-Higher-Derivatives" title="Link to this heading">¶</a></h2>
<p>Higher derivatives can be discretized in a similar way to what we did for first derivatives. Let’s consider for now only the second derivative, for which one possible approximation is the second order centered formula:</p>
<div class="math notranslate nohighlight">
\[\frac{y(t_{i+1})-2y(t_i)+y(t_{i-1})}{(\Delta t)^2} =
  y^{\prime\prime}(t_i) + {\cal O}((\Delta t)^2),\]</div>
<p>There are, of course, many other possible formulae that we might use, but this is the most commonly used.</p>
<section id="Problem-Taylor-Series">
<h3>Problem Taylor Series<a class="headerlink" href="#Problem-Taylor-Series" title="Link to this heading">¶</a></h3>
<p>(Hand in png file)</p>
<ul class="simple">
<li><p>Use Taylor series to derive the second order centered formula above</p></li>
<li><p>For more practice (although not required), try deriving a higher order approximation as well.</p></li>
</ul>
</section>
</section>
<section id="Summary">
<h2>Summary<a class="headerlink" href="#Summary" title="Link to this heading">¶</a></h2>
<p>This lab has discussed the accuracy and stability of difference schemes for simple first order ODEs. The results of the problems should have made it clear to you that choosing an accurate and stable discretization for even a very simple problem is not straightforward. One must take into account not only the considerations of accuracy and stability, but also the cost or complexity of the scheme. Selecting a numerical method for a given problem can be considered as an art in itself.</p>
</section>
<section id="Mathematical-Notes">
<h2>Mathematical Notes<a class="headerlink" href="#Mathematical-Notes" title="Link to this heading">¶</a></h2>
<section id="Taylor-Polynomials-and-Taylor-Series">
<h3>Taylor Polynomials and Taylor Series<a class="headerlink" href="#Taylor-Polynomials-and-Taylor-Series" title="Link to this heading">¶</a></h3>
<p>Taylor Series are of fundamental importance in numerical analysis. They are the most basic tool for talking about the approximation of functions. Consider a function <span class="math notranslate nohighlight">\(f(x)\)</span> that is smooth – when we say “smooth”, what we mean is that its derivatives exist and are bounded (for the following discussion, we need <span class="math notranslate nohighlight">\(f\)</span> to have <span class="math notranslate nohighlight">\((n+1)\)</span> derivatives). We would like to approximate <span class="math notranslate nohighlight">\(f(x)\)</span> near the point <span class="math notranslate nohighlight">\(x=x_0\)</span>, and we can do it as follows:</p>
<div class="math notranslate nohighlight">
\[f(x) = \underbrace{P_n(x)}_{\mbox{Taylor polynomial}} +
  \underbrace{R_n(x)}_{\mbox{remainder term}},\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[P_n(x)=f(x_0)+ f^\prime(x_0)(x-x_0) +
  \frac{f^{\prime\prime}(x_0)}{2!}(x-x_0)^2 + \cdots +
  \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\]</div>
<p>is the <em>:math:`n`th order Taylor polynomial</em> of <span class="math notranslate nohighlight">\(f\)</span> about <span class="math notranslate nohighlight">\(x_0\)</span>, and</p>
<div class="math notranslate nohighlight">
\[R_n(x)=\frac{f^{(n+1)}(\xi(x))}{(n+1)!}(x-x_0)^{n+1}\]</div>
<p>is the <em>remainder term</em> or <em>truncation error</em>. The point <span class="math notranslate nohighlight">\(\xi(x)\)</span> in the error term lies somewhere between the points <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x\)</span>. If we look at the infinite sum ( let <span class="math notranslate nohighlight">\(n\rightarrow\infty\)</span>), then the resulting infinite sum is called the <em>Taylor series of :math:`f(x)` about :math:`x=x_0`</em>. This result is also know as <em>Taylor’s Theorem</em>.</p>
<p>Remember that we assumed that <span class="math notranslate nohighlight">\(f(x)\)</span> is smooth (in particular, that its derivatives up to order <span class="math notranslate nohighlight">\((n+1)\)</span> exist and are finite). That means that all of the derivatives appearing in <span class="math notranslate nohighlight">\(P_n\)</span> and <span class="math notranslate nohighlight">\(R_n\)</span> are bounded. Therefore, there are two ways in which we can think of the Taylor polynomial <span class="math notranslate nohighlight">\(P_n(x)\)</span> as an approximation of <span class="math notranslate nohighlight">\(f(x)\)</span>:</p>
<ol class="arabic simple">
<li><p>First of all, let us fix <span class="math notranslate nohighlight">\(n\)</span>. Then, we can improve the approximation by letting <span class="math notranslate nohighlight">\(x\)</span> approach <span class="math notranslate nohighlight">\(x_0\)</span>, since as <span class="math notranslate nohighlight">\((x-x_0)\)</span> gets small, the error term <span class="math notranslate nohighlight">\(R_n(x)\)</span> goes to zero (<span class="math notranslate nohighlight">\(n\)</span> is considered fixed and all terms depending on <span class="math notranslate nohighlight">\(n\)</span> are thus constant). Therefore, the approximation improves when <span class="math notranslate nohighlight">\(x\)</span> gets closer and closer to <span class="math notranslate nohighlight">\(x_0\)</span>.</p></li>
<li><p>Alternatively, we can think of fixing <span class="math notranslate nohighlight">\(x\)</span>. Then, we can improve the approximation by taking more and more terms in the series. When <span class="math notranslate nohighlight">\(n\)</span> is increased, the factorial in the denominator of the error term will eventually dominate the <span class="math notranslate nohighlight">\((x-x_0)^{n+1}\)</span> term (regardless of how big <span class="math notranslate nohighlight">\((x-x_0)\)</span> is), and thus drive the error to zero.</p></li>
</ol>
<p>In summary, we have two ways of improving the Taylor polynomial approximation to a function: by evaluating it at points closer to the point <span class="math notranslate nohighlight">\(x_0\)</span>; and by taking more terms in the series.</p>
<p>This latter property of the Taylor expansion can be seen by a simple example. Consider the Taylor polynomial for the function <span class="math notranslate nohighlight">\(f(x)=\sin(x)\)</span> about the point <span class="math notranslate nohighlight">\(x_0=0\)</span>. All of the even terms are zero since they involve <span class="math notranslate nohighlight">\(sin(0)\)</span>, so that if we take <span class="math notranslate nohighlight">\(n\)</span> odd ( <span class="math notranslate nohighlight">\(n=2k+1\)</span>), then the <span class="math notranslate nohighlight">\(n\)</span>th order Taylor polynomial for <span class="math notranslate nohighlight">\(sin(x)\)</span> is</p>
<div class="math notranslate nohighlight">
\[P_{2k+1}(x)=x - \frac{x^3}{3!}+\frac{x^5}{5!} -\frac{x^7}{7!}+\cdots
    +\frac{x^{2k+1}}{(2k+1)!}.\ eq: taylor\]</div>
<p>The plot in Figure: Taylor illustrates quite clearly how the approximation improves both as <span class="math notranslate nohighlight">\(x\)</span> approaches 0, and as <span class="math notranslate nohighlight">\(n\)</span> is increased.</p>
<p><img alt="e328d72a4d104f2d9a8bbe5271e00ffb" class="no-scaled-link" src="../../_images/taylor.png" style="width: 60%;" /></p>
<p><strong>Figure: Taylor</strong> – Plot of <span class="math notranslate nohighlight">\(\sin(x)\)</span> compared to its Taylor polynomial approximations about <span class="math notranslate nohighlight">\(x_0=0\)</span>, for various values of <span class="math notranslate nohighlight">\(n=2k +1\)</span> in eq: taylor.</p>
<p>Consider a specific Taylor polynomial, say <span class="math notranslate nohighlight">\(P_3(x)\)</span> ( fix <span class="math notranslate nohighlight">\(n=3\)</span>). Notice that for <span class="math notranslate nohighlight">\(x\)</span> far away from the origin, the polynomial is nowhere near the function <span class="math notranslate nohighlight">\(\sin(x)\)</span>. However, it approximates the function quite well near the origin. On the other hand, we could take a specific point, <span class="math notranslate nohighlight">\(x=5\)</span>, and notice that the Taylor series of orders 1 through 7 do not approximate the function very well at all. Nevertheless the approximation improves as <span class="math notranslate nohighlight">\(n\)</span> increases, as is
shown by the 15th order Taylor polynomial.</p>
</section>
<section id="Floating-Point-Representation-of-Numbers">
<h3>Floating Point Representation of Numbers<a class="headerlink" href="#Floating-Point-Representation-of-Numbers" title="Link to this heading">¶</a></h3>
<p>Unlike a mathematician, who can deal with real numbers having infinite precision, a computer can represent numbers with only a finite number of digits. The best way to understand how a computer stores a number is to look at its <em>floating-point form</em>, in which a number is written as</p>
<div class="math notranslate nohighlight">
\[\pm 0.d_1 d_2 d_3 \ldots d_k \times 10^n,\]</div>
<p>where each digit, <span class="math notranslate nohighlight">\(d_i\)</span> is between 0 and 9 (except <span class="math notranslate nohighlight">\(d_1\)</span>, which must be non-zero). Floating point form is commonly used in the physical sciences to represent numerical values; for example, the Earth’s radius is approximately 6,400,000 metres, which is more conveniently written in floating point form as <span class="math notranslate nohighlight">\(0.64\times 10^7\)</span> (compare this to the general form above).</p>
<p>Computers actually store numbers in <em>binary form</em> (i.e. in base-2 floating point form, as compared to the decimal or base-10 form shown above). However, it is more convenient to use the decimal form in order to illustrate the basic idea of computer arithmetic. For a good discussion of the binary representation of numbers, see Burden &amp; Faires [sec. 1.2] or Newman section 4.2.</p>
<p>For the remainder of this discussion, assume that we’re dealing with a computer that can store numbers with up to 8 <em>significant digits</em> (i.e. <span class="math notranslate nohighlight">\(k=8\)</span>) and exponents in the range <span class="math notranslate nohighlight">\(-38 \leq n \leq 38\)</span>. Based on these values, we can make a few observations regarding the numbers that can be represented:</p>
<ul>
<li><dl class="simple">
<dt>The largest number that can be represented is about :math:<a href="#id5"><span class="problematic" id="id6">`</span></a>1.0times</dt><dd><p>10^{+38}`, while the smallest is <span class="math notranslate nohighlight">\(1.0\times 10^{-38}\)</span>.</p>
</dd>
</dl>
</li>
<li><p>These numbers have a lot of <em>holes</em>, where real numbers are missed. For example, consider the two consecutive floating point numbers</p>
<div class="math notranslate nohighlight">
\[0.13391482 \times 10^5 \;\;\; {\rm and} \;\;\; 0.13391483 \times 10^5,\]</div>
<p>or 13391.482 and 13391.483. Our floating-point number system cannot represent any numbers between these two values, and hence any number in between 13391.482 and 13391.483 must be approximated by one of the two values. Another way of thinking of this is to observe that <span class="math notranslate nohighlight">\(0.13391482 \times 10^5\)</span> does not represent just a single real number, but a whole <em>range</em> of numbers.</p>
</li>
<li><p>Notice that the same amount of floating-point numbers can be represented between <span class="math notranslate nohighlight">\(10^{-6}\)</span> and <span class="math notranslate nohighlight">\(10^{-5}\)</span> as are between <span class="math notranslate nohighlight">\(10^{20}\)</span> and <span class="math notranslate nohighlight">\(10^{21}\)</span>. Consequently, the density of floating points numbers increases as their magnitude becomes smaller. That is, there are more floating-point numbers close to zero than there are far away. This is illustrated in the figure below.</p>
<p>The floating-point numbers (each represented by a <span class="math notranslate nohighlight">\(\times\)</span>) are more dense near the origin.</p>
</li>
</ul>
<p><img alt="b95e84fdfc954540a3ae8164b7401eea" src="../../_images/float1.png" /></p>
<p>The values <span class="math notranslate nohighlight">\(k=8\)</span> and <span class="math notranslate nohighlight">\(-38\leq n \leq 38\)</span> correspond to what is known as <em>single precision arithmetic</em>, in which 4 bytes (or units of memory in a computer) are used to store each number. It is typical in many programming languages, including <span class="math notranslate nohighlight">\(C++\)</span>, to allow the use of higher precision, or <em>double precision</em>, using 8 bytes for each number, corresponding to values of <span class="math notranslate nohighlight">\(k=16\)</span> and <span class="math notranslate nohighlight">\(-308\leq n \leq 308\)</span>, thereby greatly increasing the range and density of numbers that can
be represented. When doing numerical computations, it is customary to use double-precision arithmetic, in order to minimize the effects of round-off error (in a <span class="math notranslate nohighlight">\(C++\)</span> program, you can define a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> to be double precision using the declaration <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">x;</span></code>).</p>
<p>Sometimes, double precision arithmetic may help in eliminating round-off error problems in a computation. On the minus side, double precision numbers require more storage than their single precision counterparts, and it is sometimes (but not always) more costly to compute in double precision. Ultimately, though, using double precision should not be expected to be a cure-all against the difficulties of round-off errors. The best approach is to use an algorithm that is not unstable with respect to
round-off error. For an example where increasing precision will not help, see the section on Gaussian elimination in Lab #3.</p>
</section>
</section>
</section>


      </div>
    </div>
  </div>
      <div class="clearer"></div>
    </div>
  

   
    <div class="footer" role="contentinfo">
    &#169; Copyright 1995 – present.
      Last updated on 24-Nov-2025.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div> <script src="//www.mozilla.org/tabzilla/media/js/tabzilla.js"></script> 
  <!-- remove loading of Mozilla tabzilla.js script -->

  </body>
</html>