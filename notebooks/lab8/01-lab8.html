<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Laboratory 8: Solution of the Quasi-geostrophic Equations &#8212; Numeric course 22.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../../_static/mozilla.css?v=18700206" />
    <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css?v=2aa19091" />
    <script src="../../_static/documentation_options.js?v=f6d600a2"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="../../_static/UBC_EOAS_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Laboratory 9: Fast Fourier Transforms" href="../lab9/01-lab9.html" />
    <link rel="prev" title="Laboratory 7: Solving partial differential equations using an explicit, finite difference method." href="../lab7/01-lab7.html" /> 
  </head><body>
<!-- remove Mozilla link tab from upper right corner of page -->


    <div class="document">
  <div class="documentwrapper">
    
    <div class="sphinxsidebar">
        <nav>
        <h2><a href="../../index.html">Numeric course</a></h2>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../ugradsyllabus.html">Undergrad Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ugrad_schedule.html">Undergrad Detailed Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gradsyllabus.html">Grad Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../grad_schedule.html">Grad Detailed Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../texts.html">Optional texts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../notebook_toc.html">Labs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rubrics.html">Rubrics</a></li>
</ul>

        </nav>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
    </div>
    <div class="bodywrapper">
      <div class="body">
        
  <section id="Laboratory-8:-Solution-of-the-Quasi-geostrophic-Equations">
<h1>Laboratory 8: Solution of the Quasi-geostrophic Equations<a class="headerlink" href="#Laboratory-8:-Solution-of-the-Quasi-geostrophic-Equations" title="Link to this heading">¶</a></h1>
<p>Lin Yang &amp; John M. Stockie</p>
<section id="List-of-Problems">
<h2>List of Problems<a class="headerlink" href="#List-of-Problems" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="#Problem-One"><span class="std std-ref">Problem 1:</span></a> Discretization of the Jacobian term</p></li>
<li><p><a class="reference internal" href="#Problem-Two"><span class="std std-ref">Problem 2:</span></a> Numerical instability in the “straightforward” Jacobian</p></li>
<li><p><a class="reference internal" href="#Problem-Three"><span class="std std-ref">Problem 3:</span></a> Implement the SOR relaxation</p></li>
<li><p><a class="reference internal" href="#Problem-Four"><span class="std std-ref">Problem 4:</span></a> No-slip boundary conditions</p></li>
<li><p><a class="reference internal" href="#Problem-Five"><span class="std std-ref">Problem 5:</span></a> Starting values for the time integration</p></li>
<li><p><a class="reference internal" href="#Problem-Six"><span class="std std-ref">Problem 6:</span></a> Duplication of classical results</p></li>
</ul>
</section>
<section id="Goals">
<h2>Goals<a class="headerlink" href="#Goals" title="Link to this heading">¶</a></h2>
<p>This lab is an introduction to the use of implicit schemes for the solution of PDE’s, using as an example the quasi-geostrophic equations that govern the large-scale circulation of the oceans.</p>
<p>You will see that the discretization of the governing equations leads to a large, sparse system of linear equations. The resulting matrix problem is solved with relaxation methods, one of which you will write the code for, by modifying the simpler Jacobi relaxation. There are two types of boundary conditions typically used for this problem, one of which you will program yourself – your computations are easily compared to previously-obtained “classical” results.</p>
</section>
<section id="Learning-Objectives">
<h2>Learning Objectives<a class="headerlink" href="#Learning-Objectives" title="Link to this heading">¶</a></h2>
<p>After reading and working through this lab you will be able to:</p>
<ul class="simple">
<li><p>Explain one reason why one may need to solve a large system of linear equations even though the underlying method is explicit</p></li>
<li><p>Describe the relaxation method</p></li>
<li><p>Rescale a partial-differential equation</p></li>
<li><p>Write down the center difference approximation for the Laplacian operator</p></li>
<li><p>Describe what a ghost point is</p></li>
</ul>
</section>
<section id="Readings">
<h2>Readings<a class="headerlink" href="#Readings" title="Link to this heading">¶</a></h2>
<p>There are no required readings for this lab. If you would like some additional background beyond the material in the lab itself, then you may refer to the references listed below:</p>
<ul class="simple">
<li><p><strong>Equations of motion:</strong></p>
<ul>
<li><p>Pedlosky Sections 4.6 &amp; 4.11 (derivation of QG equations)</p></li>
</ul>
</li>
<li><p><strong>Nonlinear instability:</strong></p>
<ul>
<li><p>Mesinger &amp; Arakawa (classic paper with description of instability and aliasing)</p></li>
<li><p>Arakawa &amp; Lamb (non-linear instability in the QG equations, with the Arakawa-Jacobian)</p></li>
</ul>
</li>
<li><p><strong>Numerical methods:</strong></p>
<ul>
<li><p>Strang (analysis of implicit schemes)</p></li>
<li><p>McCalpin (QGbox model)</p></li>
</ul>
</li>
<li><p><strong>Classical numerical results:</strong></p>
<ul>
<li><p>Veronis (numerical results)</p></li>
<li><p>Bryan (numerical results)</p></li>
</ul>
</li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">context</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span>
<span class="c1"># import the quiz script</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numlabs.lab8</span><span class="w"> </span><span class="kn">import</span> <span class="n">quiz8</span> <span class="k">as</span> <span class="n">quiz</span>
</pre></div>
</div>
</div>
</section>
<section id="Introduction">
<h2>Introduction<a class="headerlink" href="#Introduction" title="Link to this heading">¶</a></h2>
<p>An important aspect in the study of large-scale circulation in the ocean is the response of the ocean to wind stress. Solution of this problem using the full Navier-Stokes equations is quite complicated, and it is natural to look for some way to simplify the governing equations. A common simplification in many models of large-scale, wind-driven ocean circulation, is to assume a system that is homogeneous and barotropic.</p>
<p>It is now natural to ask:</p>
<blockquote>
<div><p><em>Does the simplified model capture the important dynamics in the real ocean?</em></p>
</div></blockquote>
<p>This question can be investigated by solving the equations numerically, and comparing the results to observations in the real ocean. Many numerical results are already available, and so the purpose of this lab is to introduce you to the numerical methods used to solve this problem, and to compare the computed results to those from some classical papers on numerical ocean simulations.</p>
<p>Some of the numerical details (in Sections <a class="reference internal" href="#Right-Hand-Side"><span class="std std-ref">Right Hand Side</span></a>, <a class="reference internal" href="#Boundary-Conditions"><span class="std std-ref">Boundary Conditions</span></a>, <a class="reference internal" href="#Matrix-Form-of-the-Discrete-Equations"><span class="std std-ref">Matrix Form of Discrete Equations</span></a>, <a class="reference internal" href="#Solution-of-the-Poisson-Equation-by-Relaxation"><span class="std std-ref">Solution of the Poisson Equation by Relaxation</span></a> and the appendices) are quite technical, and may be passed over the first time you read through the lab. You can get a general idea of the basic solution procedure without them. However,
you should return to them later and understand the material contained in them, since these sections contain techniques that are commonly encountered when solving PDE’s, and an understanding of these sections is required for you to answer the problems in the Lab.</p>
</section>
<section id="The-Quasi-Geostrophic-Model">
<h2>The Quasi-Geostrophic Model<a class="headerlink" href="#The-Quasi-Geostrophic-Model" title="Link to this heading">¶</a></h2>
<p>Consider a rectangular ocean with a flat bottom, as pictured in Figure Model Ocean, and ignore curvature effects, by confining the region of interest to a <em>mid-latitude :math:`beta`-plane</em>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/rect.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;45%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="Figure-Model-Ocean"><p>Figure Model Ocean The rectangular ocean with flat bottom, ignoring curvature effects.</p>
</div><p>More information on what is a <span class="math notranslate nohighlight">\(\beta\)</span>-plane and on the neglect of curvature terms in the <span class="math notranslate nohighlight">\(\beta\)</span>-plane approximation is given in the appendix.</p>
<p>If we assume that the ocean is homogeneous (it has constant density throughout), then the equations governing the fluid motion on the <span class="math notranslate nohighlight">\(\beta\)</span>-plane are:</p>
<div id="eq:xmom"><p>(X-Momentum Eqn)</p>
</div><p><span class="math">\begin{equation}
\frac{\partial u}{\partial t} + u \frac {\partial u}{\partial x} + v \frac {\partial u}{\partial y} + w \frac{\partial u}{\partial z} - fv = - \, \frac{1}{\rho} \, \frac {\partial p}{\partial x}
+ A_v \, \frac{\partial^2 u}{\partial z^2} + A_h \, \nabla^2 u
\end{equation}</span></p>
<div id="eq:ymom"><p>(Y-Momentum Eqn)</p>
</div><p><span class="math">\begin{equation}
\frac{\partial v}{\partial t} + u \frac{\partial v}{\partial x} + v \frac{\partial v}{\partial y} + w \frac{\partial v}{\partial z} + fu = - \, \frac{1}{\rho} \, \frac{\partial p}{\partial y}
+ A_v \, \frac{\partial^2 v}{\partial z^2} + A_h \, \nabla^2 v
\end{equation}</span></p>
<div id="eq:hydrostatic"><p>(Hydrostatic Eqn)</p>
</div><p><span class="math">\begin{equation}
\frac{\partial p}{\partial z} = - \rho g
\end{equation}</span></p>
<div id="eq:continuity"><p>(Continuity Eqn)</p>
</div><p><span class="math">\begin{equation}
\frac {\partial u}{\partial x} + \frac{\partial v}{\partial y} = - \, \frac{\partial w}{\partial z}
\end{equation}</span></p>
<p>where</p>
<ul class="simple">
<li><p>(X-Momentum Eqn) and (Y-Momentum Eqn) are the lateral momentum equations,</p></li>
<li><p>(Hydrostatic Eqn) is the hydrostatic balance (and replaces the vertical momentum equation), and</p></li>
<li><p>(Continuity Eqn) is the continuity (or incompressibility or conservation of volume) condition.</p></li>
</ul>
<p>The variables and parameters appearing above are:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((u,v,w)\)</span>, the fluid velocity components;</p></li>
<li><p><span class="math notranslate nohighlight">\(f(y)\)</span>, the Coriolis parameter (assumed to be a linear function of <span class="math notranslate nohighlight">\(y\)</span>);</p></li>
<li><p><span class="math notranslate nohighlight">\(\rho\)</span>, the density (assumed constant for a homogeneous fluid);</p></li>
<li><p><span class="math notranslate nohighlight">\(A_v\)</span> and <span class="math notranslate nohighlight">\(A_h\)</span>, the vertical and horizontal coefficients of viscosity, respectively (constants);</p></li>
<li><p><span class="math notranslate nohighlight">\(g\)</span>, the gravitational acceleration (constant).</p></li>
</ul>
<p>Equations (X-Momentum Eqn), (Y-Momentum Eqn), (Hydrostatic Eqn) and (Continuity Eqn) form a non-linear system of PDE’s, for which there are many numerical methods available. However, due to the complexity of the equations, the methods themselves are <em>very complex</em>, and consume a large amount of CPU time. It is therefore advantageous for us to reduce the equations to a simpler form, for which common, and more efficient
numerical solution techniques can be used.</p>
<p>By applying a sequence of physically-motivated approximations (see Appendix Simplification of the QG Model Equations) and by using the boundary conditions, the system(X-Momentum Eqn), (Y-Momentum Eqn), (Hydrostatic Eqn) and (Continuity Eqn) can be reduced to a single PDE:</p>
<div id="eq:quasi"><p>(Quasi-Geotrophic Eqn)</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial t} \, \nabla_h^2 \psi + {\cal J} \left( \psi, \nabla_h^2 \psi \right)
+ \beta \, \frac {\partial \psi}{\partial x} = \frac{1}{\rho H} \, \nabla_h \times \tau - \kappa
\, \nabla_h^2 \psi + A_h \, \nabla_h^4 \psi\]</div>
</div><p>where</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\psi\)</span> is the stream function, defined by</p>
<div class="math notranslate nohighlight">
\[u = - \frac{\partial \psi}{\partial y},\]</div>
<div class="math notranslate nohighlight">
\[v = \frac{\partial \psi}{\partial x}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\nabla_h = \left(\frac{\partial}{\partial x},\frac{\partial}{\partial y}\right)\]</div>
<p>is the “horizontal” gradient operator, so-called because it involves only derivatives in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>;</p>
</li>
<li><div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><div class="math notranslate nohighlight">
\[{\cal J} (a,b) = \frac{\partial a}{\partial x}  \frac{\partial
b}{\partial y} - \frac{\partial a}{\partial y} \frac{\partial b}{\partial x}\]</div>
</div></blockquote>
<div class="line-block">
<div class="line">is the <em>Jacobian</em> operator;</div>
</div>
</li>
<li><p><span class="math notranslate nohighlight">\(\vec{\tau}(x,y) = \left(\,\tau_1(x,y),\tau_2(x,y)\,\right)\)</span> is the wind stress boundary condition at the surface <span class="math notranslate nohighlight">\(z=0\)</span>. A simple form of the wind stress might assume an ocean “box” that extends from near the equator to a latitude of about <span class="math notranslate nohighlight">\(60^\circ\)</span>, for which typical winds are easterly near the equator and turn westerly at middle latitudes. A simple function describing this is</p>
<div class="math notranslate nohighlight">
\[\vec{\tau} = \tau_{max} (-\cos y, 0),\]</div>
<p>which is what we will use in this lab.</p>
<p>More complicated wind stress functions are possible. See McCalpin’s QGBOX documentation [p. 24] for another example.</p>
</li>
</ul>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\beta = df/dy\)</span> is a constant, where <span class="math notranslate nohighlight">\(f(y) = f_0+\beta y\)</span> (see <a class="reference internal" href="#Definition-of-the-Beta-plane"><span class="std std-ref">Appendix Definition of the Beta-plane</span></a>);</p></li>
<li><p><span class="math notranslate nohighlight">\(\kappa = {1}/{H}  \left[ (A_v f_0)/{2} \right]^{1/2}\)</span> is the bottom friction scaling (constant); and</p></li>
<li><p><span class="math notranslate nohighlight">\(H\)</span> is the vertical depth of the water column (constant).</p></li>
</ul>
<p>Notice that the original (second order) system of four equations in four unknowns (<span class="math notranslate nohighlight">\(u\)</span>, <span class="math notranslate nohighlight">\(v\)</span>, <span class="math notranslate nohighlight">\(w\)</span>, <span class="math notranslate nohighlight">\(p\)</span>) has now been reduced to a single (fourth order) PDE in one unknown function, <span class="math notranslate nohighlight">\(\psi\)</span>. It will become clear in the next section just how much simpler the system of equations has become …</p>
<p>Before going on, though, we need to close the system with the <em>boundary conditions</em> for the stream function <span class="math notranslate nohighlight">\(\psi\)</span>. We must actually consider two cases, based on whether or not the lateral eddy viscosity parameter, <span class="math notranslate nohighlight">\(A_h\)</span>, is zero:</p>
<ul class="simple">
<li><p><strong>if :math:`A_h=0`:</strong> the boundary conditions are <em>free-slip</em>; that is, <span class="math notranslate nohighlight">\(\psi=0\)</span> on the boundary.</p></li>
<li><p><strong>if :math:`A_hneq 0`:</strong> the boundary conditions are <em>no-slip</em>; that is both <span class="math notranslate nohighlight">\(\psi\)</span> and its normal derivative <span class="math notranslate nohighlight">\(\nabla\psi\cdot\hat{n}\)</span> are zero on the boundary (where <span class="math notranslate nohighlight">\(\hat{n}\)</span> is the normal vector to the boundary).</p></li>
</ul>
<section id="Scaling-the-Equations-of-Motion">
<h3>Scaling the Equations of Motion<a class="headerlink" href="#Scaling-the-Equations-of-Motion" title="Link to this heading">¶</a></h3>
<p>In physical problems, it is not uncommon for some of the quantities of interest to differ in size by many orders of magnitude. This is of particular concern when computing numerical solutions to such problems, since then round-off errors can begin to pollute the computations (see Lab 2).</p>
<p>This is also the case for the QG equations, where the parameters have a large variation in size. The QG model parameters, and typical numerical values, are given in Table of Parameters. For such problems it is customary to <em>rescale</em> the variables in such a way that the size differences are minimized.</p>
<p><strong>Problem Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Symbol</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Range of Magnitude</p></th>
<th class="head"><p>Units</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(R\)</span></p></td>
<td><p>Earth’s radius</p></td>
<td><p><span class="math notranslate nohighlight">\(6.4 \times 10^6\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\Omega\)</span></p></td>
<td><p>Angular frequency for Earth</p></td>
<td><p><span class="math notranslate nohighlight">\(7.27 \times 10^{-5}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s^{-1}\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(H\)</span></p></td>
<td><p>Depth of active layer</p></td>
<td><p><span class="math notranslate nohighlight">\(100 \rightarrow 4000\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(B\)</span></p></td>
<td><p>Length and width of ocean</p></td>
<td><p><span class="math notranslate nohighlight">\(1.0 \rightarrow 5.0 \times 10^6\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\rho\)</span></p></td>
<td><p>Density of water</p></td>
<td><p><span class="math notranslate nohighlight">\(10^3\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(kg/m^3\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(A_h\)</span></p></td>
<td><p>Lateral eddy viscosity</p></td>
<td><p><span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(10^1 \rightarrow 10^4\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m^2/s\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(A_v\)</span></p></td>
<td><p>Vertical eddy viscosity</p></td>
<td><p><span class="math notranslate nohighlight">\(10^{-4} \rightarrow 10^{-1}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m^2/s\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\tau_{max}\)</span></p></td>
<td><p>Maximum wind stress</p></td>
<td><p><span class="math notranslate nohighlight">\(10^{-2} \rightarrow 1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(kg m^{-1} s^{-2}\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\theta_0\)</span></p></td>
<td><p>Latitude</p></td>
<td><p><span class="math notranslate nohighlight">\(0 \rightarrow \frac{\pi}{3}\)</span></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Derived Quantities</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Symbol</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Range of Magnitude</p></th>
<th class="head"><p>Units</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\beta\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\beta =2\Omega \cos \theta_0 / R\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(1.1 \rightarrow 2.3 \times 10^{-11}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m^{-1} s^{-1}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(f_0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f_0 = 2 \Omega \sin \theta_0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(0.0 \rightarrow 1.3 \times 10^{-4}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(s^{-1}\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(U_0\)</span></p></td>
<td><p>Velocity scale = <span class="math notranslate nohighlight">\(\tau_{max}/(\beta\rho H B)\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(10^{-5} \rightarrow 10^{-1}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m s^{-1}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\kappa\)</span></p></td>
<td><p>bottom friction parameter</p></td>
<td><p><span class="math notranslate nohighlight">\(0.0 \rightarrow 10^{-5}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(m^2 s^{-2}\)</span></p></td>
</tr>
</tbody>
</table>
<p><strong>Non-dimensional Quantities</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Symbol / Name</p></th>
<th class="head"><p>Range of Magnitude for Quantity</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\epsilon\)</span> / Vorticity ratio = <span class="math notranslate nohighlight">\(U_0/(\beta B^2)\)</span></p></td>
<td><p>(computed)</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\frac{\tau_{max}}{\epsilon\beta^2 \rho H B^3}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(10^{-12} \rightarrow 10^{-14}\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\frac{\kappa}{\beta B}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(4 \times 10^{-4} \rightarrow 6 \times 10^1\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\frac{A_h}{\beta B^3}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(10^{-7} \rightarrow 10^{-4}\)</span></p></td>
</tr>
</tbody>
</table>
<div id="tab:parameters"><p><strong>Table of Parameters</strong></p>
</div><p>Let us go through this scaling process for the evolution equation (Quasi-Geostrophic Eqn) for the stream function, which is reproduced here for easy comparison:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial t} \nabla^2_h \psi = - \beta \frac{\partial \psi}{\partial x} - {\cal J}(\psi, \nabla_h^2\psi)+ \frac{1}{\rho H} \nabla_h \times \vec{\tau} - \kappa \nabla_h^2 \psi + A_h \nabla_h^4 \psi\]</div>
<p>The basic idea is to find typical <em>scales of motion</em>, and then redefine the dependent and independent variables in terms of these scales to obtain <em>dimensionless variables</em>.</p>
<p>For example, the basin width and length, <span class="math notranslate nohighlight">\(B\)</span>, can be used as a scale for the dependent variables <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. Then, we define dimensionless variables</p>
<div id="eq:xscale"><p>(x-scale eqn)</p>
<div class="math notranslate nohighlight">
\[x^\prime = \frac{x}{B}\]</div>
</div><div id="eq:yscale"><p>(y-scale eqn)</p>
<div class="math notranslate nohighlight">
\[y^\prime = \frac{y}{B}\]</div>
</div><p>Notice that where <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> varied between 0 and <span class="math notranslate nohighlight">\(B\)</span> (where <span class="math notranslate nohighlight">\(B\)</span> could be on the order of hundreds of kilometres), the new variables <span class="math notranslate nohighlight">\(x^\prime\)</span> and <span class="math notranslate nohighlight">\(y^\prime\)</span> now vary between 0 and 1 (and so the ocean is now a unit square).</p>
<p>Similarly, we can redefine the remaining variables in the problem as</p>
<div id="eq:tscale"><p>(t-scale eqn)</p>
<div class="math notranslate nohighlight">
\[t^\prime = \frac{t}{\left(\frac{1}{\beta B}\right)}\]</div>
</div><div id="eq:psiscale"><p>(<span class="math notranslate nohighlight">\(\psi\)</span>-scale eqn)</p>
<div class="math notranslate nohighlight">
\[\psi^\prime = \frac{\psi}{\epsilon \beta B^3}\]</div>
</div><div id="eq:tauscale"><p>(<span class="math notranslate nohighlight">\(\tau\)</span>-scale eqn)</p>
<div class="math notranslate nohighlight">
\[\vec{\tau}^\prime = \frac{\vec{\tau}}{\tau_{max}}\]</div>
</div><p>where the scales have been specially chosen to represent typical sizes of the variables. Here, the parameter <span class="math notranslate nohighlight">\(\epsilon\)</span> is a measure of the the ratio between the “relative vorticity” (<span class="math notranslate nohighlight">\(\max|\nabla_h^2 \psi|\)</span>) and the planetary vorticity (given by <span class="math notranslate nohighlight">\(\beta B\)</span>).</p>
<p>Now, we need only substitute for the original variables in the equations, and replace derivatives with their dimensionless counterparts; for example, using the chain rule,</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial x} = \frac{\partial x^\prime}{\partial x}
\frac{\partial}{\partial x^\prime}.\]</div>
<p>Then the equation of motion becomes</p>
<p>(Rescaled Quasi-Geostrophic Eqn)</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial t^\prime} \nabla^{\prime 2}_h \psi^\prime = - \, \frac{\partial \psi^\prime}{\partial x^\prime} - \epsilon {\cal J^\prime}(\psi^\prime, \nabla_h^{\prime 2}\psi^\prime) + \frac{\tau_{max}}{\epsilon \beta^2 \rho H B^3} \nabla^\prime_h \times \vec{\tau}^\prime - \, \frac{\kappa}{\beta B} \nabla_h^{\prime 2} \psi^\prime + \frac{A_h}{\beta B^3} \nabla_h^{\prime 4} \psi^\prime\]</div>
<p>The superscript “<span class="math notranslate nohighlight">\(\,^\prime\)</span>” on <span class="math notranslate nohighlight">\(\nabla_h\)</span> and <span class="math notranslate nohighlight">\({\cal J}\)</span> signify that the derivatives are taken with respect to the dimensionless variables. Notice that each term in (Rescaled Quasi-Geostrophic Eqn) is now dimensionless, and that there are now 4 dimensionless combinations of parameters</p>
<div class="math notranslate nohighlight">
\[\epsilon, \;\; \frac{\tau_{max}}{\epsilon \beta^2 \rho H B^3}, \;\; \frac{\kappa}{\beta B}, \;\; \mbox{ and} \;\; \frac{A_h}{\beta B^3}.\]</div>
<p>These four expressions define four new dimensionless parameters that replace the original (unscaled) parameters in the problem.</p>
<p>The terms in the equation now involve the dimensionless stream function, <span class="math notranslate nohighlight">\(\psi^\prime\)</span>, and its derivatives, which have been scaled so that they are now of order 1 in magnitude. The differences in sizes between terms in the equation are now embodied solely in the four dimensionless parameters. A term which is multiplied by a small parameter is thus truly small in comparison to the other terms, and hence additive round-off errors will not contribute substantially to a numerical solution
based on this form of the equations.</p>
<p>For the remainder of this lab, we will use the scaled version of the equations. Consequently, the notation will be simplified by dropping the “primes” on the dimensionless variables. But, <strong>do not forget</strong>, that any solution (numerical or analytical) from the scaled equations must be converted back into dimensional variables using the scale equations.</p>
</section>
</section>
<section id="Discretization-of-the-QG-equations">
<h2>Discretization of the QG equations<a class="headerlink" href="#Discretization-of-the-QG-equations" title="Link to this heading">¶</a></h2>
<p>At first glance, it is probably not clear how one might discretize the QG equation (Rescaled Quasi-Geostrophic Eqn) from the previous section. This equation is an evolution equation for <span class="math notranslate nohighlight">\(\nabla_h^2 \psi\)</span> (the Laplacian of the stream function) but has a right hand side that depends not only on <span class="math notranslate nohighlight">\(\nabla_h^2 \psi\)</span>, but also on <span class="math notranslate nohighlight">\(\psi\)</span> and <span class="math notranslate nohighlight">\(\nabla_h^4 \psi\)</span>. The problem may be written in a more suggestive form, by letting
<span class="math notranslate nohighlight">\(\chi = \partial\psi/\partial t\)</span>. Then, the (Rescaled Quasi-Geostrophic Eqn) becomes</p>
<p>(Poisson Eqn)</p>
<div class="math notranslate nohighlight">
\[\nabla_h^2 \chi = F(x,y,t),\]</div>
<p>where <span class="math notranslate nohighlight">\(F(x,y,t)\)</span> contains all of the terms except the time derivative. We will see that the discrete version of this equation is easily solved for the new unknown variable <span class="math notranslate nohighlight">\(\chi\)</span>, after which</p>
<div id="eq:dpsidt"><div class="math notranslate nohighlight">
\[\frac{\partial\psi}{\partial t} = \chi\]</div>
</div><p>may be used to evolve the stream function in time.</p>
<p>The next two sections discuss the spatial and temporal discretization, including some details related to the right hand side, the boundary conditions, and the iterative scheme for solving the large sparse system of equations that arises from the Poisson equation for <span class="math notranslate nohighlight">\(\chi\)</span>. Following that is an summary of the steps in the solution procedure.</p>
<section id="Spatial-Discretization">
<h3>Spatial Discretization<a class="headerlink" href="#Spatial-Discretization" title="Link to this heading">¶</a></h3>
<p>Assume that we are dealing with a square ocean, with dimensions <span class="math notranslate nohighlight">\(1\times 1\)</span> (in non-dimensional coordinates) and begin by dividing the domain into a grid of discrete points</p>
<div class="math notranslate nohighlight">
\[x_i = i \Delta x, \;\;i = 0, 1, 2, \dots, M\]</div>
<div class="math notranslate nohighlight">
\[y_j = j \Delta y, \;\;j = 0, 1, 2, \dots, N\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta x = 1/M\)</span> and <span class="math notranslate nohighlight">\(\Delta y = 1/N\)</span>. In order to simplify the discrete equations, it will be helpful to assume that <span class="math notranslate nohighlight">\(M=N\)</span>, so that <span class="math notranslate nohighlight">\(\Delta x = \Delta y \equiv d\)</span>. We can then look for approximate values of the stream function at the discrete points; that is, we look for</p>
<div class="math notranslate nohighlight">
\[\Psi_{i,j} \approx \psi(x_i,y_j)\]</div>
<p>(and similarly for <span class="math notranslate nohighlight">\(\chi_{i,j}\)</span>). The computational grid and placement of unknowns is pictured in Figure Spatial Grid.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/spatial.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;45%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="Spatial-Grid"><p>Figure Spatial Grid</p>
</div><p>Derivatives are replaced by their centered, second-order finite difference approximations</p>
<div class="math notranslate nohighlight">
\[\left. \frac{\partial \Psi}{\partial x} \right|_{i,j}
\approx
\frac{\Psi_{i+1,j}-\Psi_{i-1,j}}{2d}
\left. \frac{\partial^2 \Psi}{\partial x^2} \right|_{i,j}
\approx
\frac{\Psi_{i+1,j} - 2 \Psi_{i,j} + \Psi_{i-1,j}}{d^2}\]</div>
<p>and similarly for the <span class="math notranslate nohighlight">\(y\)</span>-derivatives. The discrete analogue of the (Poisson equation), centered at the point <span class="math notranslate nohighlight">\((x_i,y_j)\)</span>, may be written as</p>
<div class="math notranslate nohighlight">
\[\frac{\chi_{i+1,j} - 2\chi_{i,j} +\chi_{i-1,j}}{d^2} +
  \frac{\chi_{i,j+1} - 2\chi_{i,j} +\chi_{i,j-1}}{d^2}  = F_{i,j}\]</div>
<p>or, after rearranging,</p>
<p>(Discrete <span class="math notranslate nohighlight">\(\chi\)</span> Eqn)</p>
<div class="math notranslate nohighlight">
\[\chi_{i+1,j}+\chi_{i-1,j}+\chi_{i,j+1}+\chi_{i,j-1}-4\chi_{i,j} =
  d^2F_{i,j}.\]</div>
<p>Here, we’ve used <span class="math notranslate nohighlight">\(F_{i,j} = F(x_i,y_j,t)\)</span> as the values of the right hand side function at the discrete points, and said nothing of how to discretize <span class="math notranslate nohighlight">\(F\)</span> (this will be left until <a class="reference internal" href="#Right-Hand-Side"><span class="std std-ref">Right Hand Side</span></a>. The (<cite>Discrete :math:</cite>chi` equation &lt;#eq:discrete-chi&gt;`__) is an equation centered at the grid point <span class="math notranslate nohighlight">\((i,j)\)</span>, and relating the values of the approximate solution, <span class="math notranslate nohighlight">\(\chi_{i,j}\)</span>, at the <span class="math notranslate nohighlight">\((i,j)\)</span> point, to the four neighbouring values, as described by
the <em>5-point difference stencil</em> pictured in Figure Stencil.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/2diff.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;40%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:stencil"><p>Figure Stencil: The standard 5-point centered difference stencil for the Laplacian (multiply by <span class="math notranslate nohighlight">\(\frac{1}{d^2}\)</span> to get the actual coefficients.</p>
</div><p>These stencil diagrams are a compact way of representing the information contained in finite difference formulas. To see how useful they are, do the following:</p>
<ul class="simple">
<li><p>Choose the point on the grid in Figure Spatial Grid that you want to apply the difference formula (<cite>Discrete :math:</cite>chi` Eqn &lt;#eq:discrete-chi&gt;`__).</p></li>
<li><p>Overlay the difference stencil diagram on the grid, placing the center point (with value <span class="math notranslate nohighlight">\(-4\)</span>) on this point.</p></li>
<li><p>The numbers in the stencil are the multiples for each of the unknowns <span class="math notranslate nohighlight">\(\chi_{i,j}\)</span> in the difference formula.</p></li>
</ul>
<p>An illustration of this is given in Figure Overlay.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/2diffgrid.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;40%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:overlay"><p><strong>Figure Overlay:</strong> The 5-point difference stencil overlaid on the grid.</p>
</div><p>Before going any further with the discretization, we need to provide a few more details for the discretization of the right hand side function, <span class="math notranslate nohighlight">\(F(x,y,t)\)</span>, and the boundary conditions. If you’d rather skip these for now, and move on to the time discretization (<a class="reference internal" href="#Temporal-Discretization"><span class="std std-ref">Section Temporal Discretization</span></a>) or the outline of the solution procedure (<a class="reference internal" href="#Outline-of-Solution-Procedure"><span class="std std-ref">Section Outline of Solution Procedure</span></a>), then you may do so now.</p>
<section id="Right-Hand-Side">
<h4>Right Hand Side<a class="headerlink" href="#Right-Hand-Side" title="Link to this heading">¶</a></h4>
<p>The right hand side function for the (Poisson equation) is reproduced here in scaled form (with the “primes” dropped):</p>
<div class="math notranslate nohighlight">
\[F(x,y,t) = - \, \frac{\partial \psi}{\partial x} - \epsilon {\cal J}(\psi,\nabla_h^{2}\psi) + \frac{\tau_{max}}{\epsilon \beta^2 \rho H B^3} \nabla_h \times \vec{\tau} - \frac{\kappa}{\beta B} \nabla_h^{2} \psi + \frac{A_h}{\beta B^3} \nabla_h^{4} \psi\]</div>
<p>Alternatively, the Coriolis and Jacobian terms can be grouped together as a single term:</p>
<div class="math notranslate nohighlight">
\[- \, \frac{\partial\psi}{\partial x} - \epsilon {\cal J}(\psi, \nabla^2_h\psi) = - {\cal J}(\psi, y + \epsilon \nabla^2_h\psi)\]</div>
<p>Except for the Jacobian term, straightforward second-order centered differences will suffice for the Coriolis force</p>
<div class="math notranslate nohighlight">
\[\frac{\partial\psi}{\partial x} \approx \frac{1}{2d} \left(\Psi_{i+1,j} - \Psi_{i-1,j}\right),\]</div>
<p>the wind stress</p>
<div class="math notranslate nohighlight">
\[\nabla_h \times \vec{\tau} \approx
    \frac{1}{2d} \,
    \left( \tau_{2_{i+1,j}}-\tau_{2_{i-1,j}} -
      \tau_{1_{i,j+1}}+\tau_{1_{i,j-1}} \right),\]</div>
<p>and the second order viscosity term</p>
<div class="math notranslate nohighlight">
\[\nabla_h^2 \psi \approx
     \frac{1}{d^2} \left( \Psi_{i+1,j}+\Psi_{i-1,j}+\Psi_{i,j+1} +
         \Psi_{i,j-1} - 4 \Psi_{i,j} \right).\]</div>
<p>The higher order (biharmonic) viscosity term, <span class="math notranslate nohighlight">\(\nabla_h^4 \psi\)</span>, is slightly more complicated. The difference stencil can be derived in a straightforward way by splitting into <span class="math notranslate nohighlight">\(\nabla_h^2 (\nabla_h^2 \psi)\)</span> and applying the discrete version of the Laplacian operator twice. The resulting difference formula is</p>
<div id="eq:discrete-d4"><p>(Bi-Laplacian)</p>
<div class="math notranslate nohighlight">
\[\nabla_h^4 \psi
  =  \nabla_h^2 ( \nabla_h^2 \psi )\]</div>
<p></p>
<div class="math notranslate nohighlight">
\[\approx  \frac{1}{d^4} \left( \Psi_{i+2,j} + \Psi_{i,j+2} +
 \Psi_{i-2,j} + \Psi_{i,j-2} \right. + \, 2 \Psi_{i+1,j+1} + 2 \Psi_{i+1,j-1} + 2 \Psi_{i-1,j+1} +
 2 \Psi_{i-1,j-1}
\left. - 8 \Psi_{i,j+1} - 8 \Psi_{i-1,j} - 8 \Psi_{i,j-1} - 8 \, \Psi_{i+1,j} + 20 \Psi_{i,j} \right)\]</div>
</div><p>which is pictured in the difference stencil in Figure Bi-Laplacian Stencil.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/4diff.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;40%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:d4stencil"><p><strong>Figure Bi-Laplacian Stencil:</strong> 13-point difference stencil for the centered difference formula for <span class="math notranslate nohighlight">\(\nabla_h^4\)</span> (multiply by <span class="math notranslate nohighlight">\(\frac{1}{d^4}\)</span> to get the actual coefficients).</p>
</div><p>The final term is the Jacobian term, <span class="math notranslate nohighlight">\({\cal J}(\psi,
\nabla^2_h\psi)\)</span> which, as you might have already guessed, is the one that is going to give us the most headaches. To get a feeling for why this might be true, go back to (Rescaled Quasi-Geostropic Equation)  and notice that the only nonlinearity arises from this term. Typically, it is the nonlinearity in a problem that leads to difficulties in a numerical scheme. Remember the formula given for <span class="math notranslate nohighlight">\({\cal J}\)</span> in the previous section:</p>
<p>(Jacobian: Expansion 1)</p>
<div class="math notranslate nohighlight">
\[{\cal J}(a,b) = \frac{\partial a}{\partial x} \, \frac{\partial b}{\partial y} -
  \frac{\partial a}{\partial y} \, \frac{\partial b}{\partial x}\]</div>
</section>
<section id="Problem-One">
<h4>Problem One<a class="headerlink" href="#Problem-One" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>Apply the standard centered difference formula (see Lab 1 if you need to refresh you memory) to get a difference approximation to the Jacobian based on (Jacobian: Expansion 1. You will use this later in <a class="reference internal" href="#Problem-Two"><span class="std std-ref">Problem Two</span></a>.</p>
</div></blockquote>
<p>We’ve seen before that there is usually more than one way to discretize a given expression. This case is no different, and there are many possible ways to derive a discrete version of the Jacobian. Two other approaches are to apply centered differences to the following equivalent forms of the Jacobian:</p>
<div id="eq:jacob2"><p>(Jacobian: Expansion 2)</p>
<div class="math notranslate nohighlight">
\[{\cal J}(a,b) = \frac{\partial}{\partial x} \, \left( a \frac{\partial b}{\partial y} \right) -
  \frac{\partial}{\partial y} \left( a \frac{\partial b}{\partial x} \right)\]</div>
</div><div id="eq:jacob3"><p>(Jacobian: Expansion 3)</p>
<div class="math notranslate nohighlight">
\[{\cal J}(a,b) = \frac{\partial}{\partial y} \, \left( b \frac{\partial a}{\partial x} \right) -
  \frac{\partial}{\partial x} \left( b \frac{\partial a}{\partial y} \right)\]</div>
</div><p>Each formula leads to a different discrete formula, and we will see in <a class="reference internal" href="#Aliasing-Error-and-Nonlinear-Instability"><span class="std std-ref">Section Aliasing Error and Nonlinear Instability</span></a>  what effect the non-linear term has on the discrete approximations and how the use of the different formulas affect the behaviour of the numerical scheme. Before moving on, try to do the following two quizzes.</p>
</section>
<section id="Quiz-on-Jacobian-Expansion-#2">
<h4>Quiz on Jacobian Expansion #2<a class="headerlink" href="#Quiz-on-Jacobian-Expansion-#2" title="Link to this heading">¶</a></h4>
<p>Using second order centered differences, what is the discretization of the second form of the Jacobian given by</p>
<div class="math notranslate nohighlight">
\[{\cal J}(a,b) = \frac{\partial}{\partial x} \, \left( a \frac{\partial b}{\partial y} \right) -
  \frac{\partial}{\partial y} \left( a \frac{\partial b}{\partial x} \right)\]</div>
<ul>
<li><p>A:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {d^2} \left[ \left( a_{i+1,j} - a_{i-1,j} \right) \left( b_{i,j+1} - b_{i,j-1} \right) -    \left( a_{i,j+1} - a_{i,j-1} \right) \left( b_{i+1,j} - b_{i-1,j} \right) \right]\]</div>
</li>
<li><p>B:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ a_{i+1,j} \left( b_{i+1,j+1} - b_{i+1,j-1} \right) - a_{i-1,j} \left( b_{i-1,j+1} - b_{i-1,j-1} \right) - a_{i,j+1} \left( b_{i+1,j+1} - b_{i-1,j+1} \right) + a_{i,j-1} \left( b_{i+1,j-1} - b_{i-1,j-1} \right) \right]\]</div>
</li>
<li><p>C:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {d^2} \left[ \left( a_{i+1/2,j} - a_{i-1/2,j} \right) \left( b_{i,j+1/2} - b_{i,j-1/2} \right) -    \left( a_{i,j+1/2} - a_{i,j-1/2} \right) \left( b_{i+1/2,j} - b_{i-1/2,j} \right) \right]\]</div>
</li>
<li><p>D:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ b_{i+1,j} \left( a_{i+1,j+1} - a_{i+1,j-1} \right) - b_{i-1,j} \left( a_{i-1,j+1} - a_{i-1,j-1} \right) - b_{i,j+1} \left( a_{i+1,j+1} - a_{i-1,j+1} \right) + b_{i,j-1} \left( a_{i+1,j-1} - a_{i-1,j-1} \right) \right]\]</div>
</li>
<li><p>E:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ a_{i+1,j+1} \left( b_{i+1,j+1} - b_{i+1,j-1} \right) - a_{i-1,j-1} \left( b_{i-1,j+1} - b_{i-1,j-1} \right) - a_{i+1,j+1} \left( b_{i+1,j+1} - b_{i-1,j+1} \right) + a_{i-1,j-1} \left( b_{i+1,j-1} - b_{i-1,j-1} \right) \right]\]</div>
</li>
<li><p>F:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ \left( a_{i+1,j} - a_{i-1,j} \right) \left( b_{i,j+1} - b_{i,j-1} \right) -    \left( a_{i,j+1} - a_{i,j-1} \right) \left( b_{i+1,j} - b_{i-1,j} \right) \right]\]</div>
</li>
<li><p>G:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ b_{i,j+1} \left( a_{i+1,j+1} - a_{i-1,j+1} \right) - b_{i,j-1} \left( a_{i+1,j-1} - a_{i-1,j-1} \right) - b_{i+1,j} \left( a_{i+1,j+1} - a_{i+1,j-1} \right) + b_{i-1,j} \left( a_{i-1,j+1} - a_{i-1,j-1} \right) \right]\]</div>
</li>
</ul>
<p>In the following, replace ‘x’ by ‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, or ‘Hint’</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="p">(</span><span class="n">quiz</span><span class="o">.</span><span class="n">jacobian_2</span><span class="p">(</span><span class="n">answer</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="Quiz-on-Jacobian-Expansion-#3">
<h4>Quiz on Jacobian Expansion #3<a class="headerlink" href="#Quiz-on-Jacobian-Expansion-#3" title="Link to this heading">¶</a></h4>
<p>Using second order centered differences, what is the discretization of the third form of the Jacobian given by</p>
<div class="math notranslate nohighlight">
\[{\cal J}(a,b) = \frac{\partial}{\partial y} \, \left( b \frac{\partial a}{\partial x} \right) -
   \frac{\partial}{\partial x} \left( b \frac{\partial a}{\partial y} \right)\]</div>
<ul>
<li><p>A: - A:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {d^2} \left[ \left( a_{i+1,j} - a_{i-1,j} \right) \left( b_{i,j+1} - b_{i,j-1} \right) -    \left( a_{i,j+1} - a_{i,j-1} \right) \left( b_{i+1,j} - b_{i-1,j} \right) \right]\]</div>
</li>
<li><p>B:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ a_{i+1,j} \left( b_{i+1,j+1} - b_{i+1,j-1} \right) - a_{i-1,j} \left( b_{i-1,j+1} - b_{i-1,j-1} \right) - a_{i,j+1} \left( b_{i+1,j+1} - b_{i-1,j+1} \right) + a_{i,j-1} \left( b_{i+1,j-1} - b_{i-1,j-1} \right) \right]\]</div>
</li>
<li><p>C:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {d^2} \left[ \left( a_{i+1/2,j} - a_{i-1/2,j} \right) \left( b_{i,j+1/2} - b_{i,j-1/2} \right) -    \left( a_{i,j+1/2} - a_{i,j-1/2} \right) \left( b_{i+1/2,j} - b_{i-1/2,j} \right) \right]\]</div>
</li>
<li><p>D:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ b_{i+1,j} \left( a_{i+1,j+1} - a_{i+1,j-1} \right) - b_{i-1,j} \left( a_{i-1,j+1} - a_{i-1,j-1} \right) - b_{i,j+1} \left( a_{i+1,j+1} - a_{i-1,j+1} \right) + b_{i,j-1} \left( a_{i+1,j-1} - a_{i-1,j-1} \right) \right]\]</div>
</li>
<li><p>E:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ a_{i+1,j+1} \left( b_{i+1,j+1} - b_{i+1,j-1} \right) - a_{i-1,j-1} \left( b_{i-1,j+1} - b_{i-1,j-1} \right) - a_{i+1,j+1} \left( b_{i+1,j+1} - b_{i-1,j+1} \right) + a_{i-1,j-1} \left( b_{i+1,j-1} - b_{i-1,j-1} \right) \right]\]</div>
</li>
<li><p>F:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ \left( a_{i+1,j} - a_{i-1,j} \right) \left( b_{i,j+1} - b_{i,j-1} \right) -    \left( a_{i,j+1} - a_{i,j-1} \right) \left( b_{i+1,j} - b_{i-1,j} \right) \right]\]</div>
</li>
<li><p>G:</p>
<div class="math notranslate nohighlight">
\[\frac 1 {4d^2} \left[ b_{i,j+1} \left( a_{i+1,j+1} - a_{i-1,j+1} \right) - b_{i,j-1} \left( a_{i+1,j-1} - a_{i-1,j-1} \right) - b_{i+1,j} \left( a_{i+1,j+1} - a_{i+1,j-1} \right) + b_{i-1,j} \left( a_{i-1,j+1} - a_{i-1,j-1} \right) \right]\]</div>
</li>
</ul>
<p>In the following, replace ‘x’ by ‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, or ‘Hint’</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="p">(</span><span class="n">quiz</span><span class="o">.</span><span class="n">jacobian_3</span><span class="p">(</span><span class="n">answer</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="Boundary-Conditions">
<h4>Boundary Conditions<a class="headerlink" href="#Boundary-Conditions" title="Link to this heading">¶</a></h4>
<p>One question that arises immediately when applying the difference stencils in Figure Stencil and Figure Bi-Laplacian Stencil is</p>
<blockquote>
<div><p><em>What do we do at the boundary, where at least one of the nodes of the difference stencil lies outside of the domain?</em></p>
</div></blockquote>
<p>The answer to this question lies with the <em>boundary conditions</em> for <span class="math notranslate nohighlight">\(\chi\)</span> and <span class="math notranslate nohighlight">\(\psi\)</span>. We already know the boundary conditions for <span class="math notranslate nohighlight">\(\psi\)</span> from <a class="reference internal" href="#The-Quasi-Geostrophic-Model"><span class="std std-ref">Section The Quasi-Geostrophic Model</span></a>:</p>
<p>Free slip:</p>
<blockquote>
<div><p>The free slip boundary condition, <span class="math notranslate nohighlight">\(\psi=0\)</span>, is applied when <span class="math notranslate nohighlight">\(A_h=0\)</span>, which we can differentiate with respect to time to get the identical condition <span class="math notranslate nohighlight">\(\chi=0\)</span>. In terms of the discrete unknowns, this translates to the requirement that</p>
<div class="math notranslate nohighlight">
\[\Psi_{0,j} = \Psi_{N,j} = \Psi_{i,0} = \Psi_{i,N} = 0 \;\; \mbox{ for} \; i,j = 0,1,\ldots,N,\]</div>
</div></blockquote>
<blockquote>
<div><p>and similarly for <span class="math notranslate nohighlight">\(\chi\)</span>. All boundary values for <span class="math notranslate nohighlight">\(\chi\)</span> and <span class="math notranslate nohighlight">\(\Psi\)</span> are known, and so we need only apply the difference stencils at <em>interior points</em> (see Figure Ghost Points). When <span class="math notranslate nohighlight">\(A_h=0\)</span>, the high-order viscosity term is not present, and so the only stencil appearing in the discretization is the 5-point formula (the significance of this will become clear when we look at no-slip boundary conditions).</p>
</div></blockquote>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/ghost3.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;50%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:ghost"><p><strong>Figure Ghost Points:</strong> The points on the computational grid, which are classified into interior, real boundary, and ghost boundary points. The 5- and 13-point difference stencils, when overlaid on the grid, demonstrate that only the real boundary values are needed for the free-slip boundary values (when <span class="math notranslate nohighlight">\(A_h=0\)</span>), while ghost points must be introduced for the no-slip conditions (when <span class="math notranslate nohighlight">\(A_h\neq 0\)</span>, and the higher order viscosity term is present).</p>
</div><p>No-slip:</p>
<blockquote>
<div><p>The no-slip conditions appear when <span class="math notranslate nohighlight">\(A_h\neq 0\)</span>, and include the free slip conditions <span class="math notranslate nohighlight">\(\psi=\chi=0\)</span> (which we already discussed above), and the normal derivative condition <span class="math notranslate nohighlight">\(\nabla\psi\cdot\hat{n}=0\)</span>, which must be satisfied at all boundary points. It is clear that if we apply the standard, second-order centered difference approximation to the first derivative, then the difference stencil extends <em>beyond the boundary of the domain and contains at least one non-existent point!
How can we get around this problem?</em></p>
</div></blockquote>
<blockquote>
<div><p>The most straightforward approach (and the one we will use in this Lab) is to introduce a set of <em>fictitious points</em> or <em>ghost points</em>,</p>
<div class="math notranslate nohighlight">
\[\Psi_{-1,j}, \;\; \Psi_{N+1,j}, \;\; \Psi_{i,-1}, \;\; \Psi_{i,N+1}\]</div>
</div></blockquote>
<blockquote>
<div><p>for <span class="math notranslate nohighlight">\(i,j=0,1,2,\ldots,N+1\)</span>, which extend one grid space outside of the domain, as shown in Figure Ghost Points. We can then discretize the Neumann condition in a straightforward manner. For example, consider the point <span class="math notranslate nohighlight">\((0,1)\)</span>, pictured in Figure No Slip Boundary Condition, at which the discrete version of <span class="math notranslate nohighlight">\(\nabla\psi\cdot\hat{n}=0\)</span> is</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2d} ( \Psi_{1,1} - \Psi_{-1,1}, \Psi_{0,2} - \Psi_{0,0} ) \cdot (-1,0) = 0,\]</div>
</div></blockquote>
<blockquote>
<div><p>(where <span class="math notranslate nohighlight">\((-1,0)\)</span> is the unit outward normal vector), which simplifies to</p>
<div class="math notranslate nohighlight">
\[\Psi_{-1,1} = \Psi_{1,1}.\]</div>
</div></blockquote>
<blockquote>
<div><p>The same can be done for all the remaining ghost points: the value of <span class="math notranslate nohighlight">\(\Psi\)</span> at at point outside the boundary is given quite simply as the value at the corresponding interior point reflected across the boundary.</p>
</div></blockquote>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/noslip.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;40%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:noslip"><p>Figure No Slip Boundary Condition: The discrete Neumann boundary conditions are discretized using ghost points. Here, at point <span class="math notranslate nohighlight">\((0,1)\)</span>, the unit outward normal vector is <span class="math notranslate nohighlight">\(\hat{n}=(-1,0)\)</span>, and the discrete points involved are the four points circled in red. The no-slip condition simply states that <span class="math notranslate nohighlight">\(\Psi_{-1,1}\)</span> is equal to the interior value <span class="math notranslate nohighlight">\(\Psi_{1,1}\)</span>.</p>
</div><p>Now, remember that when <span class="math notranslate nohighlight">\(A_h\neq 0\)</span>, the <span class="math notranslate nohighlight">\(\nabla_h^4\psi\)</span> term appears in the equations, which is discretized as a 13-point stencil . Looking at Figure Ghost Points, it is easy to see that when the 13-point stencil is applied at points adjacent to the boundary (such as <span class="math notranslate nohighlight">\((N-1,N-1)\)</span> in the Figure) it involves not only real boundary points, but also ghost boundary points (compare this to the 5-point stencil). But, as we just discovered above, the presence of the
ghost points in the stencil poses no difficulty, since these values are known in terms of interior values of <span class="math notranslate nohighlight">\(\Psi\)</span> using the boundary conditions.</p>
<p>Just as there are many Runge-Kutta schemes, there are many finite difference stencils for the different derivatives. For example, one could use a 5-point, <span class="math notranslate nohighlight">\(\times\)</span>-shaped stencil for <span class="math notranslate nohighlight">\(\nabla^2\psi\)</span>. The flexibility of having several second-order stencils is what makes it possible to determine an energy- and enstrophy-conserving scheme for the Jacobian which we do later.</p>
<p>A good discussion of boundary conditions is given by McCalpin in his QGBOX code documentation, on page 44.</p>
</section>
<section id="Matrix-Form-of-the-Discrete-Equations">
<h4>Matrix Form of the Discrete Equations<a class="headerlink" href="#Matrix-Form-of-the-Discrete-Equations" title="Link to this heading">¶</a></h4>
<p>In order to write the discrete equations  in matrix form, we must first write the unknown values <span class="math notranslate nohighlight">\(\chi_{i,j}\)</span> in vector form. The most obvious way to do this is to traverse the grid (see Figure Spatial Grid), one row at a time, from left to right, leaving out the known, zero boundary values, to obtain the ordering:</p>
<div class="math notranslate nohighlight">
\[ \vec{\chi} =
 \left(\chi_{1,1},\chi_{2,1},\dots,\chi_{N-1,1},
   \chi_{1,2},\chi_{2,2},\dots,\chi_{N-1,2}, \dots, \right.
\left.\chi_{N-1,N-2},
   \chi_{1,N-1},\chi_{2,N-1},\dots,\chi_{N-1,N-1}\right)^T\]</div>
<p>and similarly for <span class="math notranslate nohighlight">\(\vec{F}\)</span>. The resulting matrix (with this ordering of unknowns) results in a matrix of the form given in Figure Matrix.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/matrix.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;40%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:matrix"><p>Figure Matrix: The matrix form for the discrete Laplacian. The 5 diagonals (displayed in blue and red) represent the non-zero values in the matrix <span class="math notranslate nohighlight">\(-\)</span> all other values are zero.</p>
</div><p>The diagonals with the 1’s (pictured in red) contain some zero entries due to the boundary condition <span class="math notranslate nohighlight">\(u=0\)</span>. Notice how similar this matrix appears to the <em>tridiagonal matrix</em> in the Problems from Lab 3, which arose in the discretization of the second derivative in a boundary value problem. The only difference here is that the Laplacian has an additional second derivative with respect to <span class="math notranslate nohighlight">\(y\)</span>, which is what adds the additional diagonal entries in the matrix.</p>
<p>Before you think about running off and using Gaussian elimination (which was reviewed in Lab 3), think about the size of the matrix you would have to solve. If <span class="math notranslate nohighlight">\(N\)</span> is the number of grid points, then the matrix is size <span class="math notranslate nohighlight">\(N^2\)</span>-by-<span class="math notranslate nohighlight">\(N^2\)</span>. Consequently, Gaussian elimination will require on the order of <span class="math notranslate nohighlight">\(N^6\)</span> operations to solve the matrix only once. Even for moderate values of <span class="math notranslate nohighlight">\(N\)</span>, this cost can be prohibitively expensive. For example, taking <span class="math notranslate nohighlight">\(N=101\)</span> results in a
<span class="math notranslate nohighlight">\(10000\times 10000\)</span> system of linear equations, for which Gaussian elimination will require on the order of <span class="math notranslate nohighlight">\(10000^3=10^{12}\)</span> operations! As mentioned in Lab 3, direct methods are not appropriate for large sparse systems such as this one. A more appropriate choice is an iterative or <em>relaxation scheme</em>, which is the subject of the next section..</p>
</section>
</section>
<section id="Solution-of-the-Poisson-Equation-by-Relaxation">
<h3>Solution of the Poisson Equation by Relaxation<a class="headerlink" href="#Solution-of-the-Poisson-Equation-by-Relaxation" title="Link to this heading">¶</a></h3>
<p>One thing to notice about the matrix in Figure Matrix is that it contains many zeros. Direct methods, such as Gaussian elimination (GE), are so inefficient for this problem because they operate on all of these zero entries (in fact, there are other direct methods that exploit the sparse nature of the matrix to reduce the operation count, but none are as efficient as the methods we will talk about here).</p>
<p>However, there is another class of solution methods, called <em>iterative methods</em> (refer to Lab 3) which are natural candidates for solving such sparse problems. They can be motivated by the fact that since the discrete equations are only approximations of the PDE to begin with, <em>why should we bother computing an exact solution to an approximate problem?</em> Iterative methods are based on the notion that one sets up an iterative procedure to compute successive approximations to the solution <span class="math notranslate nohighlight">\(-\)</span>
approximations that get closer and closer to the exact solution as the iteration proceeds, but never actually reach the exact solution. As long as the iteration converges and the approximate solution gets to within some tolerance of the exact solution, then we are happy! The cost of a single iterative step is designed to depend on only the number of non-zero elements in the matrix, and so is considerably cheaper than a GE step. Hence, as long as the iteration converges in a “reasonable number”
of steps, then the iterative scheme will outperform GE.</p>
<p>Iterative methods are also know as <em>relaxation methods</em>, of which the <em>Jacobi method</em> is the simplest. Here are the basic steps in the Jacobi iteration (where we’ve dropped the time superscript <span class="math notranslate nohighlight">\(p\)</span> to simplify the notation):</p>
<ol class="arabic">
<li><p>Take an initial guess, <span class="math notranslate nohighlight">\(\chi_{i,j}^{(0)}\)</span>. Let <span class="math notranslate nohighlight">\(n=0\)</span>.</p></li>
<li><p>For each grid point <span class="math notranslate nohighlight">\((i,j)\)</span>, compute the <em>residual vector</em></p>
<div class="math notranslate nohighlight">
\[R_{i,j}^{(n)} = F_{i,j} - \nabla^2\chi^{(n)}_{i,j}\]</div>
<div class="math notranslate nohighlight">
\[= F_{i,j} - \frac{1}{d^2} ( \chi_{i+1,j}^{(n)} + \chi_{i,j+1}^{(n)} + \chi_{i-1,j}^{(n)} +\chi_{i,j-1}^{(n)} - 4 \chi_{i,j}^{(n)} )\]</div>
<p>(which is non-zero unless <span class="math notranslate nohighlight">\(\chi_{i,j}\)</span> is the exact solution).</p>
<p>You should not confuse the relaxation iteration index (superscript <span class="math notranslate nohighlight">\(\,^{(n)}\)</span>) with the time index (superscript <span class="math notranslate nohighlight">\(\,^p\)</span>). Since the relaxation iteration is being performed at a single time step, we’ve dropped the time superscript for now to simplify notation. Just remember that all of the discrete values in the relaxation are evaluated at the current time level <span class="math notranslate nohighlight">\(p\)</span>.</p>
</li>
<li><p>“Adjust” <span class="math notranslate nohighlight">\(\chi_{i,j}^{(n)}\)</span>, (leaving the other neighbours unchanged) so that <span class="math notranslate nohighlight">\(R_{i,j}^{(n)}=0\)</span>. That is, replace <span class="math notranslate nohighlight">\(\chi_{i,j}^{(n)}\)</span> by whatever you need to get a zero residual. This replacement turns out to be:</p>
<div class="math notranslate nohighlight">
\[\chi_{i,j}^{(n+1)} = \chi_{i,j}^{(n)} - \frac{d^2}{4} R_{i,j}^{(n)},\]</div>
<p>which defines the iteration.</p>
</li>
<li><p>Set <span class="math notranslate nohighlight">\(n\leftarrow n+1\)</span>, and repeat steps 2 &amp; 3 until the residual is less than some tolerance value. In order to measure the size of the residual, we use a <em>relative maximum norm</em> measure, which says</p>
<div class="math notranslate nohighlight">
\[d^2 \frac{\|R_{i,j}^{(n)}\|_\infty}{\|\chi_{i,j}^{(n)}\|_\infty} &lt; TOL\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\|R_{i,j}^{(n)}\|_\infty = \max_{i,j} |R_{i,j}^{(n)}|\]</div>
<p>is the <em>max-norm</em> of <span class="math notranslate nohighlight">\(R_{i,j}\)</span>, or the maximum value of the residual on the grid (there are other error tolerances we could use but this is one of the simplest and most effective). Using this measure for the error ensures that the residual remains small <em>relative</em> to the solution, <span class="math notranslate nohighlight">\(\chi_{i,j}\)</span>. A typical value of the tolerance that might be used is <span class="math notranslate nohighlight">\(TOL=10^{-4}\)</span>.</p>
</li>
</ol>
<p>There are a few <strong>important things</strong> to note about the basic relaxation procedure outlined above</p>
<ul>
<li><p>This Jacobi method is the simplest form of relaxation. It requires that you have two storage vectors, one for <span class="math notranslate nohighlight">\(\chi_{i,j}^{(n)}\)</span> and one for <span class="math notranslate nohighlight">\(\chi_{i,j}^{(n+1)}\)</span>.</p></li>
<li><p>The relaxation can be modified by using a single vector to store the <span class="math notranslate nohighlight">\(\chi\)</span> values. In this case, as you compute the residual vector and update <span class="math notranslate nohighlight">\(\chi\)</span> at each point <span class="math notranslate nohighlight">\((i,j)\)</span>, the residual involves some <span class="math notranslate nohighlight">\(\chi\)</span> values from the previous iteration and some that have already been updated. For example, if we traverse the grid by rows (that is, loop over <span class="math notranslate nohighlight">\(j\)</span> first and then <span class="math notranslate nohighlight">\(i\)</span>), then the residual is now given by</p>
<div class="math notranslate nohighlight">
\[R_{i,j}^{(n)} = F_{i,j} - \frac{1}{d^2} ( \chi_{i+1,j}^{(n)} +
\chi_{i,j+1}^{(n)} +
\underbrace{\chi_{i-1,j}^{(n+1)} +
\chi_{i,j-1}^{(n+1)}}_{\mbox{{updated already}}} - 4
\chi_{i,j}^{(n)} ),\]</div>
<p>(where the <span class="math notranslate nohighlight">\((i,j-1)\)</span> and <span class="math notranslate nohighlight">\((i-1,j)\)</span> points have already been updated), and then the solution is updated</p>
<div class="math notranslate nohighlight">
\[\chi_{i,j}^{(n+1)} = \chi_{i,j}^{(n)} - \frac{d^2}{4} R_{i,j}^{(n)}.\]</div>
<p>Not only does this relaxation scheme save on storage (since only one solution vector is now required), but it also converges more rapidly (typically, it takes half the number of iterations as Jacobi), which speeds up convergence somewhat, but still leaves the cost at the same order as Jacobi, as we can see from Cost of Schemes Table. This is known as the <em>Gauss-Seidel</em> relaxation scheme.</p>
</li>
<li><p>In practice, we actually use a modification of Gauss-Seidel</p>
<div class="math notranslate nohighlight">
\[\chi_{i,j}^{(n+1)} = \chi_{i,j}^{(n)} - \frac{\mu d^2}{4} R_{i,j}^{(n)}\]</div>
<p>where <span class="math notranslate nohighlight">\(1&lt;\mu&lt;2\)</span> is the <em>relaxation parameter</em>. The resulting scheme is called <em>successive over-relaxation</em>, or <em>SOR</em>, and it improves convergence considerably (see Cost of Schemes Table.</p>
<p>What happens when <span class="math notranslate nohighlight">\(0&lt;\mu&lt;1\)</span>? Or <span class="math notranslate nohighlight">\(\mu&gt;2\)</span>? The first case is called <em>under-relaxation</em>, and is useful for smoothing the solution in multigrid methods. The second leads to an iteration that never converges.</p>
</li>
<li><p><em>Does the iteration converge?</em> For the Poisson problem, yes, but not in general.</p></li>
</ul>
<ul>
<li><p><em>How fast does the iteration converge?</em> and <em>How much does each iteration cost?</em> The answer to both of these questions gives us an idea of the cost of the relaxation procedure …</p>
<p>Assume we have a grid of size <span class="math notranslate nohighlight">\(N\times N\)</span>. If we used Gaussian elimination to solve this matrix system (with <span class="math notranslate nohighlight">\(N^2\)</span> unknowns), we would need to perform on the order of <span class="math notranslate nohighlight">\(N^6\)</span> operations (you saw this in Lab #3). One can read in any numerical linear algebra textbook (Strang 1988, for example), that the number of iterations required for Gauss-Seidel and Jacobi is on the order of <span class="math notranslate nohighlight">\(N^3\)</span>, while for SOR it reduces to <span class="math notranslate nohighlight">\(N^2\)</span>. There is another class of
iterative methods, called <em>multigrid methods</em>, which converge in a constant number of iterations (the optimal result)</p>
<p>If you look at the arithmetic operations performed in the the relaxation schemes described above, it is clear that a single iteration involves on the order of <span class="math notranslate nohighlight">\(N^2\)</span> operations (a constant number of multiplications for each point).</p>
<p>Putting this information together, the cost of each iterative scheme can be compared as in Cost of Schemes Table.</p>
</li>
</ul>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Order of Cost</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Gaussian Elimination</p></td>
<td><p><span class="math notranslate nohighlight">\(N^6\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Jacobi</p></td>
<td><p><span class="math notranslate nohighlight">\(N^5\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Gauss-Seidel</p></td>
<td><p><span class="math notranslate nohighlight">\(N^5\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>SOR</p></td>
<td><p><span class="math notranslate nohighlight">\(N^4\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Multigrid</p></td>
<td><p><span class="math notranslate nohighlight">\(N^2\)</span></p></td>
</tr>
</tbody>
</table>
<div id="tab:cost"><p>Cost of Schemes Table: Cost of iterative schemes compared to direct methods.</p>
</div><ul class="simple">
<li><p>Multigrid methods are obviously the best, but are also <em>extremely complicated</em> … we will stick to the much more manageable Jacobi, Gauss-Seidel and SOR schemes.</p></li>
<li><p>There are other methods (called conjugate gradient and capacitance matrix methods) which improve on the relaxation methods we’ve seen. These won’t be described here.</p></li>
</ul>
</section>
<section id="Temporal-Discretization">
<h3>Temporal Discretization<a class="headerlink" href="#Temporal-Discretization" title="Link to this heading">¶</a></h3>
<p>Let us now turn to the time evolution equation for the stream function. Supposing that the initial time is <span class="math notranslate nohighlight">\(t=0\)</span>, then we can approximate the solution at the discrete time points <span class="math notranslate nohighlight">\(t_p = p\Delta t\)</span>, and write the discrete solution as</p>
<div class="math notranslate nohighlight">
\[\Psi_{i,j}^p \approx \psi(x_i,y_j,t_p).\]</div>
<p>Notice that the spatial indices appear as subscripts and the time index as a superscript on the discrete approximation <span class="math notranslate nohighlight">\(\chi\)</span>.</p>
<p>We can choose any discretization for time that we like, but for the QG equation, it is customary (see Mesinger and Arakawa, for example) to use a centered time difference to approximate the derivative in :</p>
<div class="math notranslate nohighlight">
\[\frac{\Psi_{i,j}^{p+1} - \Psi_{i,j}^{p-1}}{2\Delta t} = \chi_{i,j}^p\]</div>
<p>or, after rearranging,</p>
<p>(Leapfrog Eqn)</p>
<div class="math notranslate nohighlight">
\[\Psi_{i,j}^{p+1} = \Psi_{i,j}^{p-1} + 2\Delta t \chi_{i,j}^p\]</div>
<p>This time differencing method is called the <em>leap frog scheme</em>, and was introduced in Lab 7. A pictorial representation of this scheme is given in Figure Leap-Frog Scheme.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/leapfrog.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;40%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:leap-frog"><p>Figure Leap-Frog Scheme: A pictorial representation of the “leap-frog” character of the time-stepping scheme. The values of <span class="math notranslate nohighlight">\(\chi\)</span> at even time steps are linked together with the odd <span class="math notranslate nohighlight">\(\Psi\)</span> values; likewise, values of <span class="math notranslate nohighlight">\(\chi\)</span> at odd time steps are linked to the even <span class="math notranslate nohighlight">\(\Psi\)</span> values.</p>
</div><p>There are two additional considerations related to the time discretization:</p>
<ul>
<li><p>The viscous terms (<span class="math notranslate nohighlight">\(\nabla_h^2\psi\)</span> and <span class="math notranslate nohighlight">\(\nabla_h^4\psi\)</span>) are evaluated at the <span class="math notranslate nohighlight">\(p-1\)</span> time points, while all other terms in the right hand side are evaluated at <span class="math notranslate nohighlight">\(p\)</span> points. The reasoning for this is described in McCalpin’s QGBOX documentation [p. 8]:</p>
<blockquote>
<div><p>Note that the frictional terms are all calculated at the old <span class="math notranslate nohighlight">\((n-1)\)</span> time level, and are therefore first-order accurate in time. This ’time lagging’ is necessary for linear computational stability.</p>
</div></blockquote>
</li>
<li><p>This second item <em>will not be implemented in this lab or the problems</em>, but should still be kept in mind …</p>
<p>The leap-frog time-stepping scheme has a disadvantage in that it introduces a “computational mode” …  McCalpin [p. 23] describes this as follows:</p>
<blockquote>
<div><p><em>Leap-frog models are plagued by a phenomenon called the “computational mode”, in which the odd and even time levels become independent. Although a variety of sophisticated techniques have been developed for dealing with this problem, McCalpin’s model takes a very simplistic approach. Every</em> narg* time steps, adjacent time levels are simply averaged together (where <em>narg</em><span class="math notranslate nohighlight">\(\approx 100\)</span> and odd)*</p>
</div></blockquote>
<p>Why don’t we just abandon the leap-frog scheme? Well, Mesinger and Arakawa [p. 18] make the following observations regarding the leap-frog scheme:</p>
<ul class="simple">
<li><p>its advantages: simple and second order accurate; neutral within the stability range.</p></li>
<li><p>its disadvantages: for non-linear equations, there is a tendency for slow amplification of the computational mode.</p></li>
<li><p>the usual method for suppressing the spurious mode is to insert a step from a two-level scheme occasionally (or, as McCalpin suggests, to occasionally average the solutions at successive time steps).</p></li>
<li><p>In Chapter 4, they mention that it is possible to construct grids and/or schemes with the same properties as leap-frog and yet the computational mode is absent.</p></li>
</ul>
<p>The important thing to get from this is that when integrating for long times, the computational mode will grow to the point where it will pollute the solution, unless one of the above methods is implemented. For simplicity, we will not be worrying about this in Lab #8.</p>
</li>
</ul>
</section>
<section id="Outline-of-Solution-Procedure">
<h3>Outline of Solution Procedure<a class="headerlink" href="#Outline-of-Solution-Procedure" title="Link to this heading">¶</a></h3>
<p>Now that we have discretized in both space and time, it is possible to outline the basic solution procedure.</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Assume that at <span class="math notranslate nohighlight">\(t=t_p\)</span>, we know :math:<a href="#id1"><span class="problematic" id="id2">`</span></a>Psi^0, Psi^1, dots,</dt><dd><p>Psi^{p-1}`</p>
</dd>
</dl>
</li>
<li><p>Calculate <span class="math notranslate nohighlight">\(F_{i,j}^p\)</span> for each grid point <span class="math notranslate nohighlight">\((i,j)\)</span> (see <a class="reference internal" href="#Right-Hand-Side"><span class="std std-ref">Section Right Hand Side</span></a>). Keep in mind that the viscosity terms (<span class="math notranslate nohighlight">\(\nabla_h^2\psi\)</span> and <span class="math notranslate nohighlight">\(\nabla_h^4\psi\)</span>) are evaluated at time level <span class="math notranslate nohighlight">\(p-1\)</span>, while all other terms are evaluated at time level <span class="math notranslate nohighlight">\(p\)</span> (this was discussed in <a class="reference internal" href="#Temporal-Discretization"><span class="std std-ref">Section Temporal Discretization</span></a>).</p></li>
<li><p>Solve the (<cite>Discrete :math:</cite>chi` equation &lt;#eq:discrete-chi&gt;`__) for <span class="math notranslate nohighlight">\(\chi_{i,j}^p\)</span> (the actual solution method will be described in <a class="reference internal" href="#Solution-of-the-Poisson-Equation-by-Relaxation"><span class="std std-ref">Section Solution of the Poisson Equation by Relaxation</span></a>.</p></li>
<li><p>Given <span class="math notranslate nohighlight">\(\chi_{i,j}^p\)</span>, we can find <span class="math notranslate nohighlight">\(\Psi_{i,j}^{p+1}\)</span> by using the (Leap-frog time stepping scheme)</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(p \leftarrow p+1\)</span> and return to step 2.</p></li>
</ol>
<p>Notice that step 1 requires a knowledge of two starting values, <span class="math notranslate nohighlight">\(\Psi^0\)</span> and <span class="math notranslate nohighlight">\(\Psi^1\)</span>, at the initial time. An important addition to the procedure below is some way to get two starting values for <span class="math notranslate nohighlight">\(\Psi\)</span>. Here are several alternatives:</p>
<ul class="simple">
<li><p>Set <span class="math notranslate nohighlight">\(\Psi^0\)</span> and <span class="math notranslate nohighlight">\(\Psi^1\)</span> both to zero.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(\Psi^0=0\)</span>, and then use a forward Euler step to find <span class="math notranslate nohighlight">\(\Psi^1\)</span>.</p></li>
<li><p>Use a predictor-corrector step, like that employed in Lab 7.</p></li>
</ul>
</section>
<section id="Problem-Two">
<h3>Problem Two<a class="headerlink" href="#Problem-Two" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Now that you’ve seen how the basic numerical scheme works, it’s time to jump into the numerical scheme. The code has already been written for the discretization described above, with free-slip boundary conditions and the SOR relaxation scheme. The code is in <strong>qg.py</strong> and the various functions are:</p>
</div></blockquote>
<blockquote>
<div><p><strong>main</strong></p>
</div></blockquote>
<p>: the main routine, contains the time-stepping and the output.</p>
<blockquote>
<div><p><strong>param()</strong></p>
</div></blockquote>
<p>: sets the physical parameters of the system.</p>
<blockquote>
<div><p><strong>numer_init()</strong></p>
</div></blockquote>
<p>: sets the numerical parameters.</p>
<blockquote>
<div><p><strong>vis(psi, nx, ny)</strong></p>
</div></blockquote>
<p>: calculates the second order (<span class="math notranslate nohighlight">\(\nabla^2\)</span>) viscosity term (not leap-frogged).</p>
<blockquote>
<div><p><strong>wind(psi, nx, ny)</strong></p>
</div></blockquote>
<p>: calculates the the wind term.</p>
<blockquote>
<div><p><strong>mybeta(psi, nx, ny)</strong></p>
</div></blockquote>
<p>: calculates the beta term</p>
<blockquote>
<div><p><strong>jac(psi, vis, nx, ny)</strong></p>
</div></blockquote>
<p>: calculate the Jacobian term. (Arakawa Jacobian given here).</p>
<blockquote>
<div><p><strong>chi(psi, vis_curr, vis_prev, chi_prev, nx, ny, dx, r_coeff, tol, max_count, epsilon, wind_par, vis_par)</strong></p>
</div></blockquote>
<p>: calculates <span class="math notranslate nohighlight">\(\chi\)</span> using a call to relax</p>
<blockquote>
<div><p><strong>relax(rhs, chi_prev, dx, nx, ny, r_coeff, tol, max_count)</strong></p>
</div></blockquote>
<p>: does the relaxation.</p>
<blockquote>
<div><p>Your task in this problem is to program the “straightforward” discretization of the Jacobian term, using (Jacobian: Expansion 1), that you derived in <a class="reference internal" href="#Problem-One"><span class="std std-ref">Problem One</span></a>. The only change this involves is inserting the code into the function <strong>jac</strong>. Once finished, run the code. The parameter functions <strong>param</strong> <strong>init_numer</strong> provide some sample parameter values for you to execute the code with. Try these input values and observe what happens in the solution.
Choose one of the physical parameters to vary. Does changing the parameter have any effect on the solution? in what way?</p>
</div></blockquote>
<blockquote>
<div><p>Hand in the code for the Jacobian, and a couple of plots demonstrating the solution as a function of parameter variation. Describe your results and make sure to provide parameter values to accompany your explanations and plots.</p>
<p>If the solution is unstable, check your CFL condition. The relevant waves are Rossby waves with wave speed:</p>
<div class="math notranslate nohighlight">
\[c=\beta k^{-2}\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is the wave-number. The maximum wave speed is for the longest wave, <span class="math notranslate nohighlight">\(k=\pi/b\)</span> where <span class="math notranslate nohighlight">\(b\)</span> is the size fo your domain.</p>
</div></blockquote>
<blockquote>
<div><p>If the code is still unstable, even though the CFL is satisfied, see <a class="reference internal" href="#Aliasing-Error-and-Nonlinear-Instability"><span class="std std-ref">Section Aliasing Error and Nonlinear Instability</span></a>. The solution is nonlinear unstable. Switch to the Arakawa Jacobian for stability.</p>
</div></blockquote>
</section>
<section id="Problem-Three">
<h3>Problem Three<a class="headerlink" href="#Problem-Three" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>The code provided for <a class="reference internal" href="#Problem-Two"><span class="std std-ref">Problem Two</span></a> implements the SOR relaxation scheme. Your job in this problem is to modify the relaxation code to perform a Jacobi iteration.</p>
</div></blockquote>
<blockquote>
<div><p>Hand in a comparison of the two methods, in tabular form. Use two different relaxation parameters for the SOR scheme. (Include a list of the physical and numerical parameter you are using). Also submit your code for the Jacobi relaxation scheme.</p>
</div></blockquote>
</section>
<section id="Problem-Four">
<h3>Problem Four<a class="headerlink" href="#Problem-Four" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Modify the code to implement the no-slip boundary conditions.</p>
</div></blockquote>
</section>
<section id="Problem-Five">
<h3>Problem Five<a class="headerlink" href="#Problem-Five" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>The code you’ve been working with so far uses the simplest possible type of starting values for the unknown stream function: both are set to zero. If you’re keen to play around with the code, you might want to try modifying the SOR code for the two other methods of computing starting values: using a forward Euler step, or a predictor-corrector step (see <a class="reference internal" href="#Outline-of-Solution-Procedure"><span class="std std-ref">Section Outline of Solution Procedure</span></a>).</p>
</div></blockquote>
</section>
</section>
<section id="Aliasing-Error-and-Nonlinear-Instability">
<h2>Aliasing Error and Nonlinear Instability<a class="headerlink" href="#Aliasing-Error-and-Nonlinear-Instability" title="Link to this heading">¶</a></h2>
<p>In <a class="reference internal" href="#Problem-Two"><span class="std std-ref">Problem Two</span></a>, you encountered an example of the instability that can occur when computing numerical solutions to some <em>nonlinear problems</em>, of which the QG equations is just one example. This effect has in fact been known for quite some time. Early numerical experiments by N. Phillips in 1956 exploded after approximately 30 days of integration due to nonlinear instability. He used the straightforward centered difference formula for as you did.</p>
<p>It is important to realize that this instability does not occur in the physical system modeled by the equations of motion. Rather is an artifact of the discretization process, something known as <em>aliasing error</em>. Aliasing error can be best understood by thinking in terms of decomposing the solution into modes. In brief, aliasing error arises in non-linear problems when a numerical scheme amplifies the high-wavenumber modes in the solution, which corresponds physically to a spurious addition of
energy into the system. Regardless of how much the grid spacing is reduced, the resulting computation will be corrupted, since a significant amount of energy is present in the smallest resolvable scales of motion. This doesn’t happen for every non-linear problem or every difference scheme, but is an issue that one who is using numerical codes must be aware of.</p>
<section id="Example-One">
<h3>Example One<a class="headerlink" href="#Example-One" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Before moving on to how we can handle the instability in our discretization of the QG equations, you should try out the following demo on aliasing error. It is taken from an example in Mesinger and Arakawa [p. 35ff.], based on the simplest of non-linear PDE’s, the advection equation:</p>
<div class="math notranslate nohighlight">
\[\frac{du}{dt}+u\frac{du}{dx} = 0.\]</div>
<p>If we decompose the solution into Fourier mode, and consider a single mode with wavenumber <span class="math notranslate nohighlight">\(k\)</span>,</p>
<div class="math notranslate nohighlight">
\[u(x) = \sin{kx}\]</div>
<p>then the solution will contain additional modes, due to the non-linear term, and given by</p>
<div class="math notranslate nohighlight">
\[u \frac{du}{dx} = k \sin{kx} \cos{kx} =\frac{1}{2}k \sin{2kx}.\]</div>
</div></blockquote>
<blockquote>
<div><p>With this as an introduction, keep the following in mind while going through the demo:</p>
<ul class="simple">
<li><p>on a computational grid with spacing <span class="math notranslate nohighlight">\(\Delta x\)</span>, the discrete versions of the modes can only be resolved up to a maximum wavenumber, <span class="math notranslate nohighlight">\(k_{max}=\frac{\pi}{\Delta x}\)</span>.</p></li>
</ul>
</div></blockquote>
<blockquote>
<div><ul class="simple">
<li><p>even if we start with modes that are resolvable on the grid, the non-linear term introduces modes with a higher wavenumber, which may it not be possible to resolve. These modes, when evaluated at discrete points, appear as modes with lower wavenumber; that is, they are <em>aliased</em> to the lower modes (this becomes evident in the demo as the wavenumber is increased …).</p></li>
<li><p>not only does aliasing occur, but for this problem, these additional modes are <em>amplified</em> by a factor of <span class="math notranslate nohighlight">\(\frac{1}{2}k\)</span>. This is the source of the <em>aliasing error</em> – such amplified modes will grow in time, no matter how small the time step taken, and will pollute the computations.</p></li>
</ul>
</div></blockquote>
<p>The previous example is obviously a much simpler non-linearity than that of the QG equations, but the net effect is the same. The obvious question we might ask now is:</p>
<blockquote>
<div><p><em>Can this problem be averted for our discretization of the QG equations with the leap-frog time-stepping scheme, or do we have to abandon it?</em></p>
</div></blockquote>
<p>There are several possible solutions, presented by Mesinger and Arakawa [p. 37], summarized here, including</p>
<ul class="simple">
<li><p>filter out the top half or third of the wavenumbers, so that the aliasing is eliminated.</p></li>
<li><p>use a differencing scheme that has a built-in damping of the shortest wavelengths.</p></li>
<li><p>the most elegant, and one that allows us to continue using the leap-frog time stepping scheme, is one suggested by Arakawa, is one that aims to eliminate the spurious inflow of energy into the system by developing a discretization of the Jacobian term that satisfies discrete analogues of the conservation properties for average vorticity, enstrophy and kinetic energy.</p></li>
</ul>
<p>This third approach will be the one we take here. The details can be found in the Mesinger-Arakawa paper, and are not essential here; the important point is that there is a discretization of the Jacobian that avoids the instability problem arising from aliasing error. This discrete Jacobian is called the <em>Arakawa Jacobian</em> and is obtained by averaging the discrete Jacobians obtained by using standard centered differences on the formulae (Jacobian: Expansion 1), (Jacobian:
Expansion 2) and (Jacobian: Expansion 3) (see <a class="reference internal" href="#Problem-One"><span class="std std-ref">Problem One</span></a> and the two quizzes following it in <a class="reference internal" href="#Right-Hand-Side"><span class="std std-ref">Section Right Hand Side</span></a>.</p>
<p>You will not be required to derive or code the Arakawa Jacobian (the details are messy!), and the code will be provided for you for all the problems following <a class="reference internal" href="#Problem-Two"><span class="std std-ref">Problem Two</span></a>.</p>
</section>
</section>
<section id="Classical-Solutions">
<h2>Classical Solutions<a class="headerlink" href="#Classical-Solutions" title="Link to this heading">¶</a></h2>
<p>Bryan (1963) and Veronis (1966)</p>
<section id="Problem-Six">
<h3>Problem Six<a class="headerlink" href="#Problem-Six" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Using the SOR code from Problems <a class="reference internal" href="#Problem-Three"><span class="std std-ref">Three</span></a> (free-slip BC’s) and <a class="reference internal" href="#Problem-Four"><span class="std std-ref">Four</span></a> (no-slip BC’s), try to reproduce the classical results of Bryan and Veronis.</p>
</div></blockquote>
</section>
</section>
<section id="Mathematical-Notes">
<h2>Mathematical Notes<a class="headerlink" href="#Mathematical-Notes" title="Link to this heading">¶</a></h2>
<section id="Definition-of-the-Beta-plane">
<h3>Definition of the Beta-plane<a class="headerlink" href="#Definition-of-the-Beta-plane" title="Link to this heading">¶</a></h3>
<p>A <span class="math notranslate nohighlight">\(\beta\)</span>-plane is a plane approximation of a curved section of the Earth’s surface, where the Coriolis parameter, <span class="math notranslate nohighlight">\(f(y)\)</span>, can be written roughly as a linear function of <span class="math notranslate nohighlight">\(y\)</span></p>
<div class="math notranslate nohighlight">
\[f(y) = f_0 + \beta y\]</div>
<p>for <span class="math notranslate nohighlight">\(f_0\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> some constants. The motivation behind this approximation follows.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/coriolis.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;30%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:globe"><p>Figure Rotating Globe: A depiction of the earth and its angular frequency of rotation, <span class="math notranslate nohighlight">\(\Omega\)</span>, the local planetary vorticity vector in blue, and the Coriolis parameter, <span class="math notranslate nohighlight">\(f_0\)</span>, at a latitude of <span class="math notranslate nohighlight">\(\theta_0\)</span>.</p>
</div><p>Consider a globe (the earth) which is rotating with angular frequency <span class="math notranslate nohighlight">\(\Omega\)</span> (see Figure Rotating Globe), and assume that the patch of ocean under consideration is at latitude <span class="math notranslate nohighlight">\(\theta\)</span>. The most important component of the Coriolis force is the local vertical (see the in Figure Rotating Globe), which is defined in terms of the Coriolis parameter, <span class="math notranslate nohighlight">\(f\)</span>, to be</p>
<div class="math notranslate nohighlight">
\[f/2 = \Omega \sin\theta.\]</div>
<p>This expression may be simplified somewhat by ignoring curvature effects and approximating the earth’s surface at this point by a plane <span class="math notranslate nohighlight">\(-\)</span> if the plane is located near the middle latitudes, then this is a good approximation. If <span class="math notranslate nohighlight">\(\theta_0\)</span> is the latitude at the center point of the plane, and <span class="math notranslate nohighlight">\(R\)</span> is the radius of the earth (see Figure Rotating Globe), then we can apply trigonometric ratios to obtain the following expression on the plane:</p>
<div class="math notranslate nohighlight">
\[f = \underbrace{2\Omega\sin\theta_0}_{f_0} +
  \underbrace{\frac{2\Omega\cos\theta_0}{R}}_\beta \, y\]</div>
<p>Not surprisingly, this plane is called a <em>mid-latitude :math:`beta`-plane</em>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/beta-plane.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;30%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div id="fig:beta"><p>Figure Beta-plane: The <span class="math notranslate nohighlight">\(\beta\)</span>-plane approximation, with points on the plane located along the local <span class="math notranslate nohighlight">\(y\)</span>-axis. The Coriolis parameter, <span class="math notranslate nohighlight">\(f\)</span>, at any latitude <span class="math notranslate nohighlight">\(\theta\)</span>, can be written in terms of <span class="math notranslate nohighlight">\(y\)</span> using trigonometric ratios.</p>
</div></section>
<section id="Simplification-of-the-QG-Model-Equations">
<h3>Simplification of the QG Model Equations<a class="headerlink" href="#Simplification-of-the-QG-Model-Equations" title="Link to this heading">¶</a></h3>
<p>The first approximation we will make eliminates several of the non-linear terms in the set of equations: (X-Momentum Eqn), (Y-Momentum Eqn), (Hydrostatic Eqn) and (Continuity Eqn). A common simplification that is made in this type of flow is the <em>quasi-geostrophic</em> (QG) approximation, where the horizontal pressure gradient and horizontal components of the Coriolis force are matched:</p>
<div class="math notranslate nohighlight">
\[fv \approx \frac{1}{\rho} \, \frac {\partial p}{\partial x}, \, \, fu \approx - \,\frac{1}{\rho}
\, \frac{\partial p}{\partial y} .\]</div>
<p>Remembering that the fluid is homogeneous (the density is constant), (Continuity Eqn) implies</p>
<div class="math notranslate nohighlight">
\[\frac{\partial^2 p}{\partial x\partial z} = 0, \, \, \frac{\partial^2 p}{\partial y\partial z} = 0.\]</div>
<p>We can then differentiate the QG balance equations to obtain</p>
<div class="math notranslate nohighlight">
\[\frac{\partial v}{\partial z} \approx 0, \, \, \frac{\partial u}{\partial z} \approx 0.\]</div>
<p>Therefore, the terms <span class="math notranslate nohighlight">\(w \, \partial u/\partial z\)</span> and <span class="math notranslate nohighlight">\(w \, \partial v/\partial z\)</span> can be neglected in ((X-Momentum Eqn)) and ((Y-Momentum Eqn)).</p>
<p>The next simplification is to eliminate the pressure terms in ((X-Momentum Eqn)) and ((Y-Momentum Eqn)) by cross-differentiating. If we define the vorticity</p>
<div class="math notranslate nohighlight">
\[\zeta = \partial v/\partial x - \partial u/\partial y\]</div>
<p>then we can cross-differentiate the two momentum equations and replace them with a single equation in <span class="math notranslate nohighlight">\(\zeta\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \zeta}{\partial t} + u \frac{\partial \zeta}{\partial x} + v \frac{\partial \zeta}{\partial y} + v\beta + (\zeta+f)(\frac {\partial u}{\partial x}+\frac{\partial v}{\partial y}) =
A_v \, \frac{\partial^2 \zeta}{\partial z^2} + A_h \, \nabla_h^2 \zeta,\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta \equiv df/dy\)</span>. Notice the change in notation for derivatives, from <span class="math notranslate nohighlight">\(\nabla\)</span> to <span class="math notranslate nohighlight">\(\nabla_h\)</span>: this indicates that derivative now appear only with respect to the “horizontal” coordinates, <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, since the <span class="math notranslate nohighlight">\(z\)</span>-dependence in the solution has been eliminated.</p>
<p>The third approximation we will make is to assume that vorticity effects are dominated by the Coriolis force, or that <span class="math notranslate nohighlight">\(|\zeta| \ll f\)</span>. Using this, along with the (Continuity Eqn) implies that</p>
<p>(Vorticity Eqn)</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \zeta}{\partial t} + u \frac {\partial \zeta}{\partial x} + v \frac{\partial \zeta}{\partial y} + v \beta -f \, \frac{\partial w}{\partial z} = A_v \,
\frac{\partial^2 \zeta}{\partial z^2} + A_h \, \nabla_h^2 \zeta .\]</div>
<p>The reason for making this simplification may not be obvious now but it is a good approximation in flows in the ocean and, as we will see next, it allows us to eliminate the Coriolis term.</p>
<p>The final sequence of simplifications eliminate the <span class="math notranslate nohighlight">\(z\)</span>-dependence in the problem by integrating (Vorticity Eqn) in the vertical direction and using boundary conditions.</p>
<p>The top 500 metres of the ocean tend to act as a single slab-like layer. The effect of stratification and rotation cause mainly horizontal motion. To first order, the upper layers are approximately averaged flow (while to the next order, surface and deep water move in opposition with deep flow much weaker). Consequently, our averaging over depth takes into account this “first order” approximation embodying the horizontal (planar) motion, and ignoring the weaker (higher order) effects.</p>
<p>First, recognize that the vertical component of velocity on both the top and bottom surfaces should be zero:</p>
<div class="math notranslate nohighlight">
\[w = 0 \;\;\; \mbox{at $z=0$}\]</div>
<div class="math notranslate nohighlight">
\[w = 0 \;\;\; \mbox{at $z=-H$}\]</div>
<p>Notice that the in second condition we’ve also assumed that the water surface is approximately flat <span class="math notranslate nohighlight">\(-\)</span> this is commonly known as the <em>rigid lid approximation</em>. Integrate the differential equation (Vorticity Eqn) with respect to <span class="math notranslate nohighlight">\(z\)</span>, applying the above boundary conditions, and using the fact that <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> (and therefore also <span class="math notranslate nohighlight">\(\zeta\)</span>) are independent of <span class="math notranslate nohighlight">\(z\)</span>,</p>
<p>(Depth-Integrated Vorticity)</p>
<div class="math notranslate nohighlight">
\[\frac{1}{H} \int_{-H}^0 \mbox{(Vorticity Eqn)} dz \Longrightarrow
\frac {\partial \zeta}{\partial t} + u \frac {\partial \zeta}{\partial x} + v \frac {\partial \zeta}{\partial y} + v\beta
= \frac{1}{H} \, \left( \left. A_v \,
    \frac{\partial \zeta}{\partial z} \right|_{z=0} - \left.  A_v \,
    \frac{\partial \zeta}{\partial z} \right|_{z=-H} \right) \, + A_h \, \nabla_h^2 \zeta\]</div>
<p>The two boundary terms on the right hand side can be rewritten in terms of known information if we apply two additional boundary conditions: the first, that the given wind stress on the ocean surface,</p>
<div class="math notranslate nohighlight">
\[\vec{\tau}(x,y) = (\tau_1,\tau_2) \;\;\mbox{at }\;\; z=0,\]</div>
<p>can be written as</p>
<div class="math notranslate nohighlight">
\[\rho A_v \left( \frac{\partial u}{\partial z} , \frac{\partial v}{\partial z} \right) = \left( \tau_1 , \tau_2
  \right)\]</div>
<p>which, after differentiating, leads to</p>
<p>(Stress Boundary Condition)</p>
<div class="math notranslate nohighlight">
\[\frac{1}{H} \, A_v \, \left. \frac{\partial \zeta}{\partial z} \right|_{z=0} = \frac{1}{\rho H} \,
  \nabla_h \times \tau \,;\]</div>
<p>and, the second, that the <em>Ekman layer</em> along the bottom of the ocean, <span class="math notranslate nohighlight">\(z=-H\)</span>, generates Ekman pumping which obeys the following relationship:</p>
<p>(Ekman Boundary Condition)</p>
<div class="math notranslate nohighlight">
\[\frac{1}{H} \, A_v \, \left. \frac{\partial \zeta}{\partial z} \right|_{z=-H} =
  \; \kappa \zeta,\]</div>
<p>where the <em>Ekman number</em>, <span class="math notranslate nohighlight">\(\kappa\)</span>, is defined by</p>
<div class="math notranslate nohighlight">
\[\kappa \equiv  \frac{1}{H}  \left( \frac{A_v f}{2} \right)^{1/2}.\]</div>
<p>Using (Stress Boundary Condition) and (Ekman Boundary Condition) to replace the boundary terms in (Depth-Integrated Vorticity), we get the following equation for the vorticity:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \zeta}{\partial t} + u \frac{\partial \zeta}{\partial x} + v \frac{\partial \zeta}{\partial y} + v \beta = \frac{1}{\rho H} \, \nabla_h
\times \tau - \kappa \zeta + A_h \, \nabla_h^2 \zeta.\]</div>
<p>The next and final step may not seem at first to be much of a simplification, but it is essential in order to derive a differential equation that can be easily solved numerically. Integrate (Continuity Eqn) with respect to <span class="math notranslate nohighlight">\(z\)</span> in order to obtain</p>
<div class="math notranslate nohighlight">
\[\frac {\partial u}{\partial x} + \frac{\partial v}{\partial y} = 0,\]</div>
<p>after which we can introduce a <em>stream function</em>, <span class="math notranslate nohighlight">\(\psi\)</span>, defined in terms of the velocity as</p>
<div class="math notranslate nohighlight">
\[u = - \, \frac{\partial \psi}{\partial y} \, , \, v = \frac{\partial \psi}{\partial x}.\]</div>
<p>The stream function satisfies this equation exactly, and we can write the vorticity as</p>
<div class="math notranslate nohighlight">
\[\zeta = \nabla_h^2 \psi,\]</div>
<p>which then allows us to write both the velocity and vorticity in terms of a single variable, <span class="math notranslate nohighlight">\(\psi\)</span>.</p>
<p>After substituting into the vorticity equation, we are left with a single equation in the unknown stream function.</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial t} \, \nabla_h^2 \psi + {\cal J} \left( \psi, \nabla_h^2 \psi \right) + \beta \, \frac {\partial \psi}{\partial x} = \frac{-1}{\rho H} \, \nabla_h \times \tau  - \, \kappa \, \nabla_h^2 \psi + A_h \, \nabla_h^4 \psi\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[{\cal J} (a,b) = \frac{\partial a}{\partial x} \, \frac{\partial b}{\partial y} - \frac{\partial a}{\partial y} \, \frac{\partial b}{\partial x}\]</div>
<p>is called the <em>Jacobian</em> operator.</p>
<p>The original system (X-Momentum Eqn), (Y-Momentum Eqn), (Hydrostatic Eqn) and (Continuity Eqn) was a system of four non-linear PDE’s, in four independent variables (the three velocities and the pressure), each of which depend on the three spatial coordinates. Now let us review the approximations made above, and their effects on this system:</p>
<ol class="arabic simple">
<li><p>After applying the QG approximation and homogeneity, two of the non-linear terms were eliminated from the momentum equations, so that the vertical velocity, <span class="math notranslate nohighlight">\(w\)</span>, no longer appears.</p></li>
<li><p>By introducing the vorticity, <span class="math notranslate nohighlight">\(\zeta\)</span>, the pressure was eliminated, and the two momentum equations to be rewritten as a single equation in <span class="math notranslate nohighlight">\(\zeta\)</span> and the velocities.</p></li>
<li><p>Some additional terms were eliminated by assuming that Coriolis effects dominate vorticity, and applying the continuity condition.</p></li>
<li><p>Integrating over the vertical extent of the ocean, and applying boundary conditions eliminated the <span class="math notranslate nohighlight">\(z\)</span>-dependence in the problem.</p></li>
<li><p>The final step consists of writing the unknown vorticity and velocities in terms of the single unknown stream function, <span class="math notranslate nohighlight">\(\psi\)</span>.</p></li>
</ol>
<p>It is evident that the final equation is considerably simpler: it is a single, non-linear PDE for the unknown stream function, <span class="math notranslate nohighlight">\(\psi\)</span>, which is a function of only two independent variables. As we will see in the next section, this equation is of a very common type, for which simple and efficient numerical techniques are available.</p>
</section>
</section>
<section id="Glossary">
<h2>Glossary<a class="headerlink" href="#Glossary" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>advection:</strong> A property or quantity transferred by the flow of a fluid is said to be “advected” by the flow. aliasing error: In a numerical scheme, this is the phenomenon that occurs when a grid is not fine enough to resolve the high modes in a solution. These high waveumbers consequently appear as lower modes in the solution due to aliasing. If the scheme is such that these high wavenumber modes are amplified, then the aliased modes can lead to a significant error in the computed solution.</p></li>
<li><p><strong>:math:`beta`-plane:</strong> A <span class="math notranslate nohighlight">\(\beta\)</span>-plane is a plane approximation of a curved section of the Earth’s surface, where the Coriolis parameter can be written roughly as a linear function.</p></li>
<li><p><strong>continuity equation:</strong> The equation that describes mass conservation in a fluid, <span class="math notranslate nohighlight">\({\partial \rho}/{\partial t} + \nabla \cdot (\rho \vec u) = 0\)</span></p></li>
<li><p><strong>Coriolis force:</strong> An additional force experienced by an observer positioned in a rotating frame of reference. If <span class="math notranslate nohighlight">\(\Omega\)</span> is the angular velocity of the rotating frame, and <span class="math notranslate nohighlight">\(\vec u\)</span> is the velocity of an object observed within the rotating frame, then the Coriolis force, <span class="math notranslate nohighlight">\(\Omega \times \vec u\)</span>, appears as a force tending to deflect the moving object to the right.</p></li>
<li><p><strong>Coriolis parameter:</strong> The component of the planetary vorticity which is normal to the earth’s surface, usually denoted by f.</p></li>
<li><p><strong>difference stencil:</strong> A convenient notation for representing difference approximation formula for derivatives.</p></li>
<li><p><strong>Ekman layer:</strong> The frictional layer in a geophysical fluid flow field which appears on a rigid surface perpendicular to the rotation vector.</p></li>
<li><p><strong>Gauss-Seidel relaxation:</strong> One of a class of iterative schemes for solving systems of linear equations. See Lab 8 for a complete discussion.</p></li>
<li><p><strong>homogeneous fluid:</strong> A fluid with constant density. Even though the density of ocean water varies with depth, it is often assumed homogeneous in order to simplify the equations of motion.</p></li>
<li><p><strong>hydrostatic balance:</strong> A balance, in the vertical direction, between the vertical pressure gradient and the buoyancy force. The pressure difference between any two points on a vertical line is assumed to depend only on the weight of the fluid between the points, as if the fluid were at rest, even though it is actually in motion. This approximation leads to a simplification in the equations of fluid flow, by replacing the vertical momentum equation.</p></li>
<li><p><strong>incompressible fluid:</strong> A fluid for which changes in the density with pressure are negligible. For a fluid with velocity field, <span class="math notranslate nohighlight">\(\vec u\)</span>, this is expressed by the equation <span class="math notranslate nohighlight">\(\nabla \cdot \vec u = 0\)</span>. This equation states that the local increase of density with time must be balanced by the divergence of the mass flux.</p></li>
<li><p><strong>Jacobi relaxation:</strong> The simplest of the iterative methods for solving linear systems of equations. See Lab 8 for a complete discussion.</p></li>
<li><p><strong>momentum equation(s):</strong> The equations representing Newton’s second law of motion for a fluid. There is one momentum equation for each component of the velocity.</p></li>
<li><p><strong>over-relaxation:</strong> Within a relaxation scheme, this refers to the use of a relaxation parameter <span class="math notranslate nohighlight">\(\mu &gt; 1\)</span>. It accelerates the standard Gauss-Seidel relaxation by forcing the iterates to move closer to the actual solution.</p></li>
</ul>
<ul class="simple">
<li><p><strong>Poisson equation:</strong> The partial differential equation <span class="math notranslate nohighlight">\(\nabla^2 u = f\)</span> or, written two dimensions, <span class="math notranslate nohighlight">\({\partial^2 u}/{\partial x^2} + {\partial^2 u}/{\partial y^2} =f(x,y)\)</span>.</p></li>
<li><p><strong>QG:</strong> abbreviation for quasi-geostrophic.</p></li>
<li><p><strong>quasi-geostrophic balance:</strong> Approximate balance between the pressure gradient and the Coriolis Force.</p></li>
<li><p><strong>relaxation:</strong> A term that applies to a class of iterative schemes for solving large systems of equations. The advantage to these schemes for sparse matrices (compared to direct schemes such as Gaussian elimination) is that they operate only on the non-zero entries of the matrix. For a description of relaxation methods, see Lab 8.</p></li>
</ul>
<ul class="simple">
<li><p><strong>rigid lid approximation:</strong> Assumption that the water surface deflection is negligible in the continuity equation (or conservation of volume equation)</p></li>
<li><p><strong>SOR:</strong> see successive over-relaxation.</p></li>
<li><p><strong>sparse system:</strong> A system of linear equations whose matrix representation has a large percentage of its entries equal to zero.</p></li>
<li><p><strong>stream function:</strong> Incompressible, two-dimensional flows with velocity field <span class="math notranslate nohighlight">\((u,v)\)</span>, may be described by a stream function, <span class="math notranslate nohighlight">\(\psi(x, y)\)</span>, which satisfies <span class="math notranslate nohighlight">\(u = −{\partial \psi}/{\partial y}, v = {\partial \psi}/{\partial x}\)</span>. These equations are a consequence of the incompressibility condition.</p></li>
<li><p><strong>successive over-relaxation:</strong> An iterative method for solving large systems of linear equations. See Lab 8 for a complete discussion.</p></li>
<li><p><strong>under-relaxation:</strong> Within a relaxation scheme, this refers to the use of a relaxation parameter <span class="math notranslate nohighlight">\(\mu &lt; 1\)</span>. It is not appropriate for solving systems of equations directly, but does have some application to multigrid methods.</p></li>
<li><p><strong>vorticity:</strong> Defined to be the curl of the velocity field, <span class="math notranslate nohighlight">\(\zeta = \nabla \times \vec u\)</span>. In geophysical flows, where the Earth is a rotating frame of reference, the vorticity can be considered as the sum of a relative vorticity (the curl of the velocity in the nonrotating frame) and the planetary vorticity, <span class="math notranslate nohighlight">\(2 \Omega\)</span>. For these large-scale flows, vorticity is almost always present, and the planetary vorticity dominates.</p></li>
</ul>
</section>
<section id="References">
<h2>References<a class="headerlink" href="#References" title="Link to this heading">¶</a></h2>
<div id="Ref:ArakawaLamb"><p>Arakawa, A. and V. R. Lamb, 1981: A potential enstrophy and energy conserving scheme for the shallow water equations. Monthly Weather Review, 109, 18–36.</p>
</div><div id="Ref:Bryan"><p>Bryan, K., 1963: A numerical investigation of a non-linear model of a wind-driven ocean. Journal of Atmospheric Science, 20, 594–606</p>
</div><div id="Ref:McCalpin"><p>On the adjustment of azimuthally perturbed vortices. Journal of Geophysical Research, 92, 8213–8225.</p>
</div><div id="Ref:MesingerArakawa"><p>Mesinger, F. and A. Arakawa, 1976: Numerical Methods Used in Atmospheric Models,GARP Publications Series No.~17, Global Atmospheric Research Programme.</p>
</div><div id="Ref:Pedlosky"><p>Pedlosky, J., 1987: Geophysical Fluid Dynamics. Springer-Verlag, New York, 2nd edition.Pond,</p>
</div><div id="Ref:Phillips"><p>Phillips, N. A., 1956: The general circulation of the atmosphere: A numerical experiment. Quarterly Journal of the Royal Meteorological Society, 82, 123–164.</p>
</div><div id="Ref:Strang"><p>Strang, G., 1988: Linear Algebra and its Applications. Harcourt Brace Jovanovich, San Diego, CA, 2nd edition.</p>
</div><div id="Ref:Veronis"><p>Veronis, G., 1966: Wind-driven ocean circulation – Part 2. Numerical solutions of the non- linear problem. Deep Sea Research, 13, 31–55.</p>
</div><div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


      </div>
    </div>
  </div>
      <div class="clearer"></div>
    </div>
  

   
    <div class="footer" role="contentinfo">
    &#169; Copyright 1995 – present.
      Last updated on 24-Nov-2025.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div> <script src="//www.mozilla.org/tabzilla/media/js/tabzilla.js"></script> 
  <!-- remove loading of Mozilla tabzilla.js script -->

  </body>
</html>