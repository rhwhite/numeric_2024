<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Laboratory 10: Numerical Advection Schemes &#8212; Numeric course 22.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../../_static/mozilla.css?v=18700206" />
    <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css?v=2aa19091" />
    <script src="../../_static/documentation_options.js?v=f6d600a2"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="../../_static/UBC_EOAS_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Links to rubrics" href="../../rubrics.html" />
    <link rel="prev" title="Laboratory 9: Fast Fourier Transforms" href="../lab9/01-lab9.html" /> 
  </head><body>
<!-- remove Mozilla link tab from upper right corner of page -->


    <div class="document">
  <div class="documentwrapper">
    
    <div class="sphinxsidebar">
        <nav>
        <h2><a href="../../index.html">Numeric course</a></h2>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../ugradsyllabus.html">Undergrad Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ugrad_schedule.html">Undergrad Detailed Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gradsyllabus.html">Grad Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../grad_schedule.html">Grad Detailed Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../texts.html">Optional texts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../notebook_toc.html">Labs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rubrics.html">Rubrics</a></li>
</ul>

        </nav>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
    </div>
    <div class="bodywrapper">
      <div class="body">
        
  <section id="Laboratory-10:-Numerical-Advection-Schemes">
<h1>Laboratory 10: Numerical Advection Schemes<a class="headerlink" href="#Laboratory-10:-Numerical-Advection-Schemes" title="Link to this heading">¶</a></h1>
<p>Carmen Guo</p>
<section id="Learning-Goals">
<h2>Learning Goals<a class="headerlink" href="#Learning-Goals" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Explain why modelling advection is particularly difficult</p></li>
<li><p>Explain and contrast diffusion and dispersion</p></li>
<li><p>Define positive definite</p></li>
</ul>
</section>
<section id="List-of-Problems">
<h2>List of Problems<a class="headerlink" href="#List-of-Problems" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="#Problem-One"><span class="std std-ref">Problem One</span></a></p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">context</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="c1"># make the plots happen inline</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="c1"># import the numpy array handling library</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="c1"># import the advection code from the numlabs directory</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numlabs.lab10.advection_funs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">afs</span>
</pre></div>
</div>
</div>
</section>
<section id="Advection-Process">
<h2>Advection Process<a class="headerlink" href="#Advection-Process" title="Link to this heading">¶</a></h2>
<p>The word advection means ‘transfer of heat through the horizontal motion of a flow’. More generally, we will consider a flow of some non-diffusive quantity. For example, consider the wind as a flow and the water vapour in the air as the non-diffusive quantity. Suppose the wind is travelling in the positive x direction, and we are considering the vapour concentration from <span class="math notranslate nohighlight">\(x=1\)</span> to <span class="math notranslate nohighlight">\(x=80\)</span>.</p>
<p>Assume that initially the distribution curve of the vapour is Gaussian (Figure Initial Distribution). Ideally, the water droplets move at the same speed as that of the air, so the distribution curve retains its initial shape as it travels along the x-axis. This process is described by the following PDE:</p>
<p>(Advection Eqn)</p>
<div class="math notranslate nohighlight">
\[\frac{\partial c}{\partial t} + u \frac{\partial c}{\partial x} = 0\]</div>
<p>where <span class="math notranslate nohighlight">\(c\)</span> is the concentration of the water vapour, and <span class="math notranslate nohighlight">\(u\)</span> is the speed of the wind (assuming the wind is blowing at constant speed).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/initial.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;60%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><strong>Figure Initial Distribution:</strong> This is the initial distribution of water vapour concentration.</p>
<p>As you will see in the upcoming examples, it is not easy to obtain a satisfactory numerical solution to this PDE.</p>
</section>
<section id="Simple-Solution-Using-Centred-Differencing-Scheme">
<h2>Simple Solution Using Centred Differencing Scheme<a class="headerlink" href="#Simple-Solution-Using-Centred-Differencing-Scheme" title="Link to this heading">¶</a></h2>
<p>Let’s start off simple and solve the PDE (Advection Eqn) using centred differences, <em>i.e.</em>, by expanding the time and spatial derivatives in the following way:</p>
<p>(Centered Difference Scheme)</p>
<div class="math notranslate nohighlight">
\[\frac{\partial c}{\partial t}(x=m dx, t=n dt) =\frac {c(x=m dx, t=(n+1) dt) - c(x=m dx, t=(n-1) dt)}{2 dt}\]</div>
<div class="math notranslate nohighlight">
\[\frac{\partial c}{\partial x}(x=m dx, t=n dt)=\frac {c(x=(m+1) dx, t=n dt) - c(x=(m-1) dx, t=n dt)}{2 dx}\]</div>
<p>where <span class="math notranslate nohighlight">\(m=2, \ldots, 79\)</span>, and <span class="math notranslate nohighlight">\(n=2, \ldots\)</span>. Substitution of the equations into the PDE yields the following recurrence relation:</p>
<div class="math notranslate nohighlight">
\[c(m, n+1)= c(m, n-1) - u \frac{dt}{dx} (c(m+1, n) - c(m-1, n))\]</div>
<p>The boundary conditions are :</p>
<div class="math notranslate nohighlight">
\[c(x=1 dx)= c(x=79 dx)\]</div>
<div class="math notranslate nohighlight">
\[c(x=80 dx)= c(x=2 dx)\]</div>
<p>The initial conditions are:</p>
<div class="math notranslate nohighlight">
\[c(x=n dx) = \exp( - \alpha (n dx - \hbox{offset})^2)\]</div>
<p>where <span class="math notranslate nohighlight">\(\hbox{offset}\)</span> is the location of the peak of the distribution curve. We don’t want the peak to be located near <span class="math notranslate nohighlight">\(x=0\)</span> due to the boundary conditions.</p>
<p>Now we need the values of <span class="math notranslate nohighlight">\(c\)</span> at <span class="math notranslate nohighlight">\(t= 1 dt\)</span> to calculate <span class="math notranslate nohighlight">\(c\)</span> at <span class="math notranslate nohighlight">\(t= 2 dt\)</span>, and we will use the Forward Euler scheme to approximate <span class="math notranslate nohighlight">\(c\)</span> at <span class="math notranslate nohighlight">\(t= 1 dt\)</span>. So</p>
<div class="math notranslate nohighlight">
\[\frac{\partial c}{\partial t}(m, 0)= \frac {c(m, 1) - c(m, 0)}{dt}\]</div>
<p>Substitution of the equations into the PDE yields</p>
<div class="math notranslate nohighlight">
\[c(m, 1) = c(m, 0) - u \frac{dt}{2 dx}(c(m+1, 0) - c(m-1, 0))\]</div>
<p>where <span class="math notranslate nohighlight">\(m=2, \ldots, 79\)</span>. The end points at <span class="math notranslate nohighlight">\(t= 1 dt\)</span> can be found using the boundary conditions.</p>
<p>The function that computes the numerical solution using this scheme is in <em>advection_funs.py</em>. It is a python function <em>advection(timesteps)</em>, which takes in the number of time steps as input and plots the distribution curve at 20 time steps.</p>
<p>We can see the problem with this scheme just by running the function with 10 time steps (Figure Distribution with Centered Scheme). Following is a plot of the distribution curve at the last time step.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/centered.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;60%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><strong>Figure Distribution with Centered Scheme:</strong> This is the distribution after 10 time steps approximated using the centred differencing scheme.</p>
<p>Comparing this curve with the initial state (Figure Initial Distribution), we can see that ripples are produced to the left of the curve which means negative values are generated. But water vapour does not have negative concentrations. The centred differencing scheme does not work well for the advection process because it is not <strong>positive definite</strong>, <em>i.e.</em>, it generates negative values which are impossible in real life.</p>
<p>Another example of using the same scheme</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">afs</span><span class="o">.</span><span class="n">advection</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lab_example</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Numerical-Solution-Using-Upstream-Method">
<h2>Numerical Solution Using Upstream Method<a class="headerlink" href="#Numerical-Solution-Using-Upstream-Method" title="Link to this heading">¶</a></h2>
<p>Let’s see what is wrong with our simple centred differencing scheme. We used centred differences to compute the time and spatial derivatives (Centered Difference Scheme). In other words, <span class="math notranslate nohighlight">\(c(x=m dx)\)</span> depends on <span class="math notranslate nohighlight">\(c(x=(m-1) dx)\)</span> and <span class="math notranslate nohighlight">\(c(x=(m+1) dx)\)</span>, and <span class="math notranslate nohighlight">\(c(t=n dt)\)</span> depends on <span class="math notranslate nohighlight">\(c(t=(n-1) dt)\)</span> and <span class="math notranslate nohighlight">\(c(t=(n+1) dt)\)</span>. But we know the wind is moving in the positive x direction, so <span class="math notranslate nohighlight">\(c(x=m dx)\)</span> should not depend on <span class="math notranslate nohighlight">\(c(x=(m+1) dx)\)</span>.
Therefore, we will change the centred differencing scheme to backward differencing scheme. In other words, we will always be looking ‘upstream’ in the approximation.</p>
<p>If we use backward differences to approximate the spatial derivative but continue to use centred differences to approximate the time derivative, we will end up with an unstable scheme. Thus, we will use backward differences for both time and spatial derivatives. Now the time and spatial derivatives are given by:</p>
<p>(Upstream Scheme)</p>
<div class="math notranslate nohighlight">
\[\frac{\partial c}{\partial t}(x=m dx, t=n dt)=\frac {c(x=m dx, t=n dt) - c(x=m dx, t=(n-1) dt)}{dt}\]</div>
<div class="math notranslate nohighlight">
\[\frac{\partial c}{\partial x}(x=m dx, t=n dt)=\frac {c(x=m dx, t=n dt) - c(x=(m-1) dx, t=n dt)}{dx}\]</div>
<p>Substitution of the equations into the PDE yields</p>
<div class="math notranslate nohighlight">
\[c(m, n+1)=c(m, n)- u \frac{dt}{dx} (c(m, n) - c(m-1, n))\]</div>
<p>The boundary conditions and the initial conditions are the same as in the centred differencing scheme. This time we compute <span class="math notranslate nohighlight">\(c\)</span> at <span class="math notranslate nohighlight">\(t= 1 dt\)</span> using backward differences just as with all subsequent time steps.</p>
<p>The function that computes the solution using this scheme is in <em>advection_funs.py</em>. It is a python function <em>advection2(timesteps)</em>, which takes in the number of time steps as input and plots the distribution curve at 20 time steps.</p>
<p>Although this scheme is positive definite and conservative (the area under the curve is the same as in the initial state), it introduces a new problem — diffusion. As the time step increases, you can see that the curve becomes wider and lower, <em>i.e.</em>, it diffuses quickly (Figure Upstream Distribution).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/upstream.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;60%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><strong>Figure Upstream Distribution:</strong> This is the distribution after 60 time steps approximated using the upstream method.</p>
<p>But ideally, the curve should retain its original shape as the wave travels along the x-axis, so the upstream method is still not good enough for the advection problem. In the next section, we will present another method that does a better job.</p>
<p>Another example using the same scheme</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">afs</span><span class="o">.</span><span class="n">advection2</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">lab_example</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="A-Better-Solution">
<h2>A Better Solution<a class="headerlink" href="#A-Better-Solution" title="Link to this heading">¶</a></h2>
<p>In previous sections, we were concerned with values at grid points only, ie, values of <span class="math notranslate nohighlight">\(c\)</span> at <span class="math notranslate nohighlight">\(x= 1dx, 2dx, \ldots\)</span>. But in this section, we will also consider grid boxes each containing a grid point in the centre. For each grid point <span class="math notranslate nohighlight">\(j\)</span>, the left boundary of the grid box containing <span class="math notranslate nohighlight">\(j\)</span> is indexed as <span class="math notranslate nohighlight">\(j- 1/2\)</span>, and the right boundary as <span class="math notranslate nohighlight">\(j+ 1/2\)</span>. The scheme presented here was developed by Andreas Bott (Bott, 1989).</p>
<p>The PDE (Advection Eqn) is rewritten as :</p>
<p>(Flux Form Eqn)</p>
<div class="math notranslate nohighlight">
\[\frac{\partial c}{\partial t} + \frac{\partial uc}{\partial x} = 0\]</div>
<p>where <span class="math notranslate nohighlight">\(F= uc\)</span> gives the flux of water vapour.</p>
<p>Expand the time derivative using forward differences and the spatial derivative as follows:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial F}{\partial x}(x=j dx)  = \frac {F(x= (j+1/2) dx) - F(x= (j-1/2) dx)}{dx}\]</div>
<p>where <span class="math notranslate nohighlight">\(F(x= j+1/2)\)</span> gives the flux through the right boundary of the grid box <span class="math notranslate nohighlight">\(j\)</span>. For simplicity, we use the notation <span class="math notranslate nohighlight">\(F(x= j+1/2)\)</span> for <span class="math notranslate nohighlight">\(F(x= j+1/2, n)\)</span>, ie, the flux through the right boundary of the grid box j after <span class="math notranslate nohighlight">\(n\)</span> time steps.</p>
<p>Substituting the expanded derivatives into the PDE, we obtain the following recurrence formula (<span class="math notranslate nohighlight">\(c(m, n)= c(x= m dx, t= n dt)\)</span>):</p>
<div class="math notranslate nohighlight">
\[c(m, n+1)= c(m, n) - \frac {dt} {dx}(F(m+1/2, n)-F(m-1/2, n))\]</div>
<p>Since flux is defined as the amount flowing through per unit time, we need to calculate the portion of the distribution curve in each grid box that passes the right boundary after <span class="math notranslate nohighlight">\(dt\)</span></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/flux.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;60%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><strong>Figure Amount Leaving Grid:</strong> After <span class="math notranslate nohighlight">\(dt\)</span>, the shaded area will be past the right boundary of the grid box <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>As (Figure Amount Leaving Grid) shows, the distribution curve in grid box <span class="math notranslate nohighlight">\(j\)</span> has travelled a distance of <span class="math notranslate nohighlight">\({u dt}\)</span> after each time step; in other words, the curve has moved <span class="math notranslate nohighlight">\(u dt/dx\)</span> of a grid space within a time unit. The shaded region is the portion of the vapour that passes the right boundary of grid box <span class="math notranslate nohighlight">\(j\)</span> within <span class="math notranslate nohighlight">\(dt\)</span>. We can use integration to find out the area of the shaded region and then divide the result by <span class="math notranslate nohighlight">\(dt\)</span> to get
<span class="math notranslate nohighlight">\(F(j+1/2)\)</span>.</p>
<p>Since we only know <span class="math notranslate nohighlight">\(c\)</span> at the grid point <span class="math notranslate nohighlight">\(j\)</span>, we are going to use polynomial interpolation techniques to approximate <span class="math notranslate nohighlight">\(c\)</span> at other points in the grid box. We define <span class="math notranslate nohighlight">\(c\)</span> in grid box <span class="math notranslate nohighlight">\(j\)</span> with a polynomial of order <span class="math notranslate nohighlight">\(l\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[c _{j, \ell}(x^\prime) = \sum _{k=0} ^{\ell} a _{j, k} x ^{\prime k}\]</div>
<p>where <span class="math notranslate nohighlight">\(x^\prime = (x- x_j)/dx\)</span> and <span class="math notranslate nohighlight">\(-1/2 \le x^\prime \le \ell/2\)</span>.</p>
<p>The coefficients <span class="math notranslate nohighlight">\(a _{j, k}\)</span> are obtained by interpolating the curve with the aid of neighbouring grid points. We will skip the detail of the interpolation process. Values of <span class="math notranslate nohighlight">\(a _{j, k}\)</span> for <span class="math notranslate nohighlight">\(\ell=0, 1, \ldots, 4\)</span> have been computed and are summarised in Tables <cite>Table :math:</cite>ell=0` &lt;#tab:ell0&gt;`__, <cite>Table :math:</cite>ell=1` &lt;#tab:ell1&gt;`__, <cite>Table :math:</cite>ell=2` &lt;#tab:ell2&gt;`__, <cite>Table :math:</cite>ell=3` &lt;#tab:ell3&gt;`__ and <cite>Table :math:</cite>ell=4` &lt;#tab:ell4&gt;`__,</p>
<p><strong>Table :math:`ell = 0`:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j,0}=c_j\)</span></p></td>
</tr>
</tbody>
</table>
<p><strong>Table :math:`ell = 1`:</strong> two representations</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j,0}= c_j\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 1}= c_{j+1} - c_j\)</span></p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j,0}= c_j\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 1}= c_j-c_{j-1}\)</span></p></td>
</tr>
</tbody>
</table>
<p><strong>Table :math:`ell = 2`:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j,0}= c_j\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 1}=\frac {1}{2}(c_{j+1}-c_{j-1})\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 2}=\frac {1}{2}(c_{j+1}-2c_j+c_{j-1})\)</span></p></td>
</tr>
</tbody>
</table>
<p><strong>Table :math:`ell = 3`:</strong> two representations</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j,0}= c_j\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 1}=\frac {1}{6}(-c_{j+2}+6c_{j+1}-3c_j-2c_{j-1})\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 2}=\frac {1}{2}(c_{j+1}-2c_j+c_{j-1})\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=3\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 3}=\frac {1}{6}(c_{j+2}-3c_{j+1}+3c_j-c_{j-1})\)</span></p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j,0}= c_j\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 1}=\frac {1}{6}(2c_{j+1}+3c_j-6{j-1}+c_{j-2})\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 2}=\frac {1}{2}(c_{j+1}-2c_j+c_{j-1})\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=3\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 3}=\frac {1}{6}(c_{j+1}-3c_j+3c_{j-1}-c_{j-2})\)</span></p></td>
</tr>
</tbody>
</table>
<p><strong>Table :math:`ell = 4`:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=0\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j,0}= c_j\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 1}=\frac {1}{12}(-c_{j+2}+8c_{j+1}-8c_{j-1}+c_{j-2})\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 2}=\frac {1}{24}(-c_{j+2}+16c_{j+1}-30c_j+16c_{j-1}-c_{j-2})\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(k=3\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 3}=\frac {1}{12}(c_{j+2}-2c_{j+1}+2c_{j-1}-c_{j-2})\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k=4\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(a_{j, 4}=\frac {1}{24}(c_{j+2}-4c_{j+1}+6c_j-4c_{j-1}+c_{j-2})\)</span></p></td>
</tr>
</tbody>
</table>
<p>Note that for even order polynomials, an odd number of <span class="math notranslate nohighlight">\(c\)</span> values including the grid point <span class="math notranslate nohighlight">\(j\)</span> are needed to calculate the coefficients <span class="math notranslate nohighlight">\(a_{j, k}\)</span>. This means the same number of grid points to the left and right of <span class="math notranslate nohighlight">\(x_j\)</span> are used in the calculation of <span class="math notranslate nohighlight">\(a_{j, k}\)</span>. If on the other hand, we choose odd order polynomials, there will be one extra point used to either side of <span class="math notranslate nohighlight">\(x_j\)</span>, thus resulting in 2 different representations of <span class="math notranslate nohighlight">\(a_{j, k}\)</span>. This is why there
are 2 sets of <span class="math notranslate nohighlight">\(a_{j, k}\)</span> for <span class="math notranslate nohighlight">\(\ell=1, 3\)</span> in the table. Decision as to which set is to be used must be made according to specific conditions of the calculation.</p>
<p>If we choose <span class="math notranslate nohighlight">\(\ell=0\)</span>, we will end up with the upstream method. In other words, the upstream method assumes that <span class="math notranslate nohighlight">\(c\)</span> is constant in each grid box. This poor representation of <span class="math notranslate nohighlight">\(c\)</span> results in strong numerical diffusion. Experiments have shown that generally if we use higher order polynomials (where <span class="math notranslate nohighlight">\(\ell \le 4\)</span>), we can significantly suppress numerical diffusion.</p>
<p>Now we define <span class="math notranslate nohighlight">\(I_{j+1/2}\)</span> as the shaded area in grid box <span class="math notranslate nohighlight">\(j\)</span> in (Figure Amount Leaving Grid):</p>
<p>(Flux Leaving Eqn)</p>
<div class="math notranslate nohighlight">
\[I_{j+1/2} = \int _{1/2 - \frac{udt}{dx}}^{1/2} c_j(x^\prime) dx^\prime\]</div>
<div class="math notranslate nohighlight">
\[=  \sum _{k=0}^{l} \frac {a_{j, k}}{(k+1) 2^{k+1}} \left[1- \left(1- 2 u \frac{dt}{dx}\right)^{k+1} \right]\]</div>
<p>Note that we are integrating over <span class="math notranslate nohighlight">\(x^\prime\)</span> instead of <span class="math notranslate nohighlight">\(x\)</span>. Thus, to get the real shaded area, we need to multiply <span class="math notranslate nohighlight">\(I_{j+1/2}\)</span> by <span class="math notranslate nohighlight">\(dx\)</span>. So</p>
<p>(Flux Eqn)</p>
<div class="math notranslate nohighlight">
\[F_{j+1/2}= \frac {dx} {dt}I_{j+1/2}\]</div>
<p>In this form, the scheme is conservative and weakly diffusive. But it still lacks positive definiteness. A sufficient condition for this is</p>
<p>(Positive Definite Condition)</p>
<div class="math notranslate nohighlight">
\[0 \le  I_{j+1/2} dx  \le  c_j dx\]</div>
<p>That is, the total outflow is never negative and never greater than <span class="math notranslate nohighlight">\(c_j dx\)</span>. In other words, the shaded area should be no less than zero but no greater than the area of the rectangle with length <span class="math notranslate nohighlight">\(c_j\)</span> and width <span class="math notranslate nohighlight">\(dx\)</span>. (Figure Total in Cell) shows why the total outflow should be limited above by <span class="math notranslate nohighlight">\(c_j dx\)</span>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;images/limit.png&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;60%&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><strong>Figure Total in Cell:</strong> The shaded area is equal to <span class="math notranslate nohighlight">\(c_j dx\)</span>, and it is already greater than the total amount of vapour (the area under the curve) in grid box <span class="math notranslate nohighlight">\(j\)</span>. If <span class="math notranslate nohighlight">\(I_{j+1/2} dx &gt; c_j dx\)</span>, then the total outflow <span class="math notranslate nohighlight">\(I_{j+1/2} dx\)</span> would be greater than the amount of vapour in the grid box, and the amount of vapour will be negative at the next time step, thus violating the positive definiteness requirement.</p>
<p>If the total outflow is larger than the shaded area <span class="math notranslate nohighlight">\(c_j dx\)</span>, we will get negative values of <span class="math notranslate nohighlight">\(c\)</span> in this grid box at the next time step. We do not want this to happen since negative values are meaningless.</p>
<p>To satisfy the condition for positive definiteness (Positive Definite Condition) we need to guarantee that <span class="math notranslate nohighlight">\(I_{j+1/2} \le c_j\)</span> holds at all time steps. We can achieve this condition by multiplying <span class="math notranslate nohighlight">\(I_{j+1/2}\)</span> by a weighting factor. Define <span class="math notranslate nohighlight">\(I_{j+1/2}^\prime\)</span> as</p>
<p>(Normalization Eqn)</p>
<div class="math notranslate nohighlight">
\[I_{j+1/2}^\prime=I_{j+1/2} \frac {c_j}{I_j}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[{I_j} = \int_{-1/2}^{1/2} c_j(x^\prime) dx^\prime\]</div>
<div class="math notranslate nohighlight">
\[= \sum_{k=0}^{l} \frac {a_{j, k}} {(k+1) 2^{k+1}} [(-1)^k +1]\]</div>
<p>Since the total flow out of a grid box is always less than the total grid volume, <span class="math notranslate nohighlight">\(I_{j+1/2}/I_j\)</span> is always less than 1, thus <span class="math notranslate nohighlight">\(I_{j+1/2} c_j/I_j\)</span> is always less than <span class="math notranslate nohighlight">\(c_j\)</span>. Thus we can satisfy the upper limit of the positive definiteness condition (Positive Definite Condition) by multiplying <span class="math notranslate nohighlight">\(I_{j+1/2}\)</span> by a weighting factor <span class="math notranslate nohighlight">\(c_j/I_j\)</span>. So now <span class="math notranslate nohighlight">\(F\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[F_{j+1/2}= \frac {dx} {dt}\frac {c_j}{I_j} I_{j+1/2}\]</div>
<p>Now to satisfy the lower limit of the positive definiteness condition, (Positive Definite Condition) we need to make sure <span class="math notranslate nohighlight">\(I_{j+1/2}\)</span> remains non negative at all time steps. So we will set <span class="math notranslate nohighlight">\(I_{j+1/2}\)</span> to 0 whenever it is negative.</p>
<p>If we are looking at the parts of the curve that are far away from the peak, <span class="math notranslate nohighlight">\(I_j=0, I_{j+1/2}=0\)</span>, and we will be dividing by 0 in (Normalization Eqn)! To avoid this instability, we introduce a small term <span class="math notranslate nohighlight">\(\epsilon\)</span> when <span class="math notranslate nohighlight">\(I_j=0, I_{j+1/2}=0\)</span>, <em>i.e.</em>, we set <span class="math notranslate nohighlight">\(I_j\)</span> to <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<p>Combining all the conditions from above, the advection scheme is described as follows:</p>
<div class="math notranslate nohighlight">
\[c(j, n+1)= c(j, n) - \frac {dt} {dx} [F(j+1/2, n)- F(j-1/2, n)]\]</div>
<div class="math notranslate nohighlight">
\[F(j+1/2, n)= \frac {dx}{dt} \frac {i_{l, j+1/2}}{i_{l, j}} c_j\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[i_{l, j+1/2} = \hbox{max}(0, I_{j+1/2})\]</div>
<div class="math notranslate nohighlight">
\[i_{l, j} = \hbox{max}(I_{l, j}, i_{l, j+1/2} + \epsilon)\]</div>
<p>where <span class="math notranslate nohighlight">\(l\)</span> is the order of the polynomial we use to interpolate <span class="math notranslate nohighlight">\(c\)</span> in each grid box.</p>
<p>An example function for this scheme is in <em>advection_funs.py</em>. The python function <em>advection3(timesteps, order)</em> takes in 2 arguments, the first is the number of time steps to be computed, the second is the order of the polynomial for the approximation of <span class="math notranslate nohighlight">\(c\)</span> within each grid box. It plots the curve at 20 time steps. Students should try it out and compare this scheme with the previous two.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">afs</span><span class="o">.</span><span class="n">advection3</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">lab_example</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<section id="Problem-One">
<h3>Problem One<a class="headerlink" href="#Problem-One" title="Link to this heading">¶</a></h3>
<p>Using the Bott Scheme, modify initialize in <em>advection_funs.py</em> to solve the following advection problem: The wind is moving along the x-axis with speed u=20 m/s. The initial distribution curve is 50 km in width. Use your program to approximate the curve during 24 hours.</p>
<ol class="loweralpha simple">
<li><p>Run your program for different orders of approximating polynomials (up to 4). Compare the accuracy of approximation for different orders. Do you see better results with increasing order? Is this true for all orders from 0 to 4? Is there any particularity to odd and even order polynomials? What if you decrease or increase the Courant number (value in front of dx/u for dt calculation)?</p></li>
</ol>
<p>b) For odd ordered polynomials, <em>advection_funs.py</em> uses the representation of <span class="math notranslate nohighlight">\(a_{j,k}\)</span> that involves an extra point to the right of the centre grid point. Modify the table of coefficients for odd ordered polynomials (<cite>Table :math:</cite>ell=1` &lt;#tab:ell1&gt;`__)and (<cite>Table :math:</cite>ell=3` &lt;#tab:ell3&gt;`__) to use the extra point to the left of the centre grid point. Run your program again and compare the results of 2 different representations of <span class="math notranslate nohighlight">\(a_{j,k}\)</span> for order 1 and 3, respectively. Is
one representation better than the other, or about the same, or does each have its own problem? How, do you think the different representation affects the result?</p>
<ol class="loweralpha simple" start="3">
<li><p>What happens if you increase the Courant number to greater than one? Hint: check the speed.</p></li>
</ol>
</section>
</section>
<section id="Conclusion">
<h2>Conclusion<a class="headerlink" href="#Conclusion" title="Link to this heading">¶</a></h2>
<p>The last scheme presented solves 2 problems introduced in the previous two schemes. The centred differencing scheme lacks positive definiteness because it is of second order accuracy, thus it introduces additional oscillations near the peak. The scheme presented here solves this problem by checking and normalising the relevant values (ie, <span class="math notranslate nohighlight">\(I_{j+1/2}\)</span> and <span class="math notranslate nohighlight">\(I_j\)</span>) when needed at each time step. The upstream scheme produces strong diffusion because it is of only first order accuracy. The
scheme presented here solves this problem by using higher order polynomials to approximate <span class="math notranslate nohighlight">\(c\)</span> at each grid box.</p>
<p>Experiments have shown that this scheme is numerically stable in most atmospheric situations. This scheme is only slightly unstable in the case of strong deformational flow field models.</p>
<p>For more detail about this advection scheme , please refer to (Bott, 1989). Since 1989, new advection schemes including the MUSCL and TVD have been developed and are more routinely used.</p>
</section>
<section id="References">
<h2>References<a class="headerlink" href="#References" title="Link to this heading">¶</a></h2>
<p>Bott, A., 1989: A positive definite advection scheme obtained by nonlinear renormalization of the advective fluxes. <em>Monthly Weather Review</em>, 117, 1006–1015.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


      </div>
    </div>
  </div>
      <div class="clearer"></div>
    </div>
  

   
    <div class="footer" role="contentinfo">
    &#169; Copyright 1995 – present.
      Last updated on 24-Nov-2025.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div> <script src="//www.mozilla.org/tabzilla/media/js/tabzilla.js"></script> 
  <!-- remove loading of Mozilla tabzilla.js script -->

  </body>
</html>